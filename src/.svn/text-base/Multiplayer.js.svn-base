////
// Multiplayer.js
// Provides persisent state for objects and network event stream.
// 
// DHTML Game Engine 1.0
// Copyright (c) 2005 - 2008 Joseph Huckaby
////

function _Multiplayer() {
	// singleton
	this.enabled = false;
	this._state = this._STATE_OFF;
	this._server_hostname = '127.0.0.1'; // SET AT COMPILE TIME
	this._server_port = '6201';
	
	// reference to MP sprite plane
	this._sprite_plane = null;
	
	// info about authoritative sprites
	this._sprites = {};
	
	// actual data to be serialized to the socket
	this._sprite_data = {};
	
	this._msg_queue = [];
	this._incoming_data = null;
	this._last_read = 0;
	this._last_write = 0;
	this._target_fps = 8;
}

// Inherit from EventHandlerBase, to get setHandler(), fireHandler(), et al.
_Multiplayer.prototype = new _EventHandlerBase();

_Multiplayer.prototype._STATE_OFF = 0;
_Multiplayer.prototype._STATE_LOADING = 1;
_Multiplayer.prototype._STATE_LOADED = 2;
_Multiplayer.prototype._STATE_CONNECTING = 3;
_Multiplayer.prototype._STATE_CONNECTED = 4;

_Multiplayer.prototype._setup = function(_callback) {
	// create our socket, called from gGame
	this.setHandler('onLoad', _callback);
	
	if (this._state == this._STATE_OFF) {
		this._state = this._STATE_LOADING;
		this._loadTimer = setTimeout( function() { gMulti._loadTimeout(); }, 1000 * 10 );
		this._socket = new _Socket( [this, '_socketLoaded'] );
	}
};

_Multiplayer.prototype._loadTimeout = function() {
	// socket failed to load, stop game loading right here (fatal error)
	this.enabled = false;
	this._state = this._STATE_OFF;
	return _throwError("Multiplayer support failed to load.  Please upgrade to the latest Adobe Flash Player and try again.");
};

_Multiplayer.prototype._socketLoaded = function() {
	// socket is loaded, continue game core load
	if (this._state == this._STATE_LOADING) {
		debugstr("Socket loaded successfully, continuing game core load");
		this._state = this._STATE_LOADED;
		if (this._loadTimer) clearTimeout( this._loadTimer );
		this._loadTimer = null;
		this.fireHandler('onLoad');
	}
};

_Multiplayer.prototype._connect = function() {
	// connect to server and begin streaming data to/from
	if (this._state == this._STATE_LOADED) {
		this._state = this._STATE_CONNECTING;
		this._connectTimer = setTimeout( function() { gMulti._connectTimeout(); }, 1000 * 10 );
		this._socket.setHandler( 'onConnect', [this, '_socketConnected'] );
		this._socket._connect( this._server_hostname, this._server_port );
	}
};

_Multiplayer.prototype._connectTimeout = function() {
	// socket failed to connect within a reasonable amount of time
	// this.enabled = false;
	this._state = this._STATE_LOADED;
	gSocketManager.onError( this.socket.id, "Connect Timeout -- Will Retry" );
};

_Multiplayer.prototype._socketConnected = function() {
	// connected successfully, cancel timeout
	debugstr("Socket connected successfully");
	this._state = this._STATE_CONNECTED;
	if (this._connectTimer) clearTimeout( this._connectTimer );
	this._connectTimer = null;
	socket.setHandler( 'onData', [this, '_dataReceived'] );
};

_Multiplayer.prototype.logic = function() {
	// handle logic loop
	if (!this.enabled) return;
	if (this._state != this._STATE_CONNECTED) return this._connect();
	
	if (this._incoming_data) {
		// handle incoming data from the server
		var _cmds = this._incoming_data.cmd;
		if (_cmds && _cmds.length) {
			// commands from the server, execute immediately
			for (var _idx = 0, _len = _cmds.length; _idx < _len; _idx++) {
				var _cmd = _cmds[_idx];
				if (_cmd.func && this[_cmd.func]) this[_cmd.func].apply(this, _cmd.args);
			} // foreach command
		} // packet contained commands
		
		var _msgs = this._incoming_data.msg;
		if (_msgs && _msgs.length) {
			// messages from the server
			for (var _idx = 0, _len = _msgs.length; _idx < _len; _idx++) {
				var _msg = _msgs[_idx];
				
				// TODO: handle message
				
			} // foreach message
		} // packet contained messages
		
		var _sprs = this._incoming_data.spr;
		if (_sprs) {
			// network sprite updates
			for (var _id in _sprs) {
				var _spr = _sprs[_id];
				
				// TODO: update sprite
				
			} // foreach sprite
		} // packet has sprite data
		
		this._incoming_data = null;
	} // process incoming server data
	
	// determine when to write next socket chunk
	var _maxDelay = 1 / this._target_fps;
	var _now = _now_epoch();
	var _write_at = (this._last_read + _maxDelay) - (this._last_read - this._last_write);
	if (_now >= _write_at) {
		// time to write data to achieve target FPS, based on last read/write lag
		
		// collect all network sprite data into staging area
		
		
		// serialize using PSON (Perl Script Object Notation)
		this._socket._write( serialize({ msg: this._msg_queue, spr: this._sprite_data }, '=>') );
		this._msg_queue = [];
		this._last_write = _now;
	}
};

_Multiplayer.prototype._dataReceived = function(_numBytes) {
	// received data from the socket
	var _data = this.socket._read();
	if (_data) {
		try {
			// TODO: Replace with native JSON parsing, if supported by browser
			this._incoming_data = eval(_data);
		}
		catch (e) {
			// error eval()ing data, log and will try again in next loop
			assert(false, "Error parsing data from socket stream: " + _data + "\n\n" + e.toString());
		}
	}
	else {
		assert(false, "Read nothing from the socket.");
	}
	this._last_read = _now_epoch();
};

_Multiplayer.prototype._addSprite = function(_sprite) {
	// add sprite to network list
	// must be previously created with createMPSprite() to have a network global ID, not a local ID
	this._sprites[ _sprite.id ] = _sprite;
};

_Multiplayer.prototype.broadcastEvent = function(_obj) {
	
};

_Multiplayer.prototype.sendPrivateEvent = function(_user_id, _obj) {
	
};

_Multiplayer.prototype.saveUserData = function(_obj) {
	
};

// Singleton
var gMulti = new _Multiplayer();


















































