=article_title Platformer Tutorial
=article_path /tutorials
=article_tags tutorial, platformer, sprites, tiles
=article_stags sidebar_tutorials
=article_comments 1
=section_numbers 1
=toc 1
=toc_max 3

=section #. Overview

=preview This tutorial walks you through creating a simple, sidescrolling platformer game.  You control a player using keyboard controls, with actions including running, jumping, and throwing rocks at various enemies.  The world has simple gravity, and collision detection.  There are multiple planes of parallax scrolling, which are created easily without having to write any code.

=image /effect/images/docs/tutorials/platformer/screenshot.jpg style="border:0; cursor:pointer;" onClick="window.open('/effect/games/tutorial1/1.0b')"

<center><table><tr><td>[button:controller.png /effect/games/tutorial1/1.0b Play Game Now...]</td></tr></table></center>

This tutorial walks you through creating a simple, sidescrolling platformer game.  You control a player using keyboard controls, with actions including running, jumping, and throwing rocks at various enemies.  The world has simple gravity, and collision detection.  There are multiple planes of parallax scrolling, which are created easily without having to write any code.  Here are the default key controls (you can customize these if you want):

=deflist
	Move | Arrow Keys, or "A" and "D".
	Jump | Space, or "X".
	Throw Rock | Comma, or "Z".
	Pause | Enter or Escape.

You are free to copy and use any of the code in this tutorial for your own games.  It is released under the [http://www.opensource.org/licenses/lgpl-3.0.html GNU Lesser General Public License v3.0].  However, please note that most of the audio was purchased from [http://www.shockwave-sound.com Shockwave-Sound.com], and some of the graphics (namely the trees) were purchased from [http://www.istockphoto.com iStockPhoto.com]. These *cannot* be reused in your games without purchasing your own license from them.

It is recommended you first read the [article:docs/Getting Started Guide] and [article:docs/Sprites and Tiles Guide], before reading this tutorial.

=section #.#. Topics

The following topics are covered in this tutorial:

=list
	Preparing and uploading assets.
	Creating sprite and tile classes.
	Designing levels in the Level Editor.
	Writing sprite and tile code.
	Simple collision detection.
	Keyboard control handling.
	Adding sound effects and music.
	Adding a heads-up display.
	Adding a title screen.

=section #. The Basics

This section covers basic game setup, including uploading game assets, and designing a level.  The main game display for this game is 512x320 pixels, with a target frame rate at 45 fps.  Everything else is set at the defaults.

=section #.#. Assets

For this game we'll be using the following graphic assets:

=section #.#.#. Level Backgrounds

In the far background we have an image of some clouds and sky:

=image /effect/api/view/games/tutorial1/assets/images/backgrounds/sky.jpg

This image is seamlessly looped so it can repeat horizontally (scaled down here for display purposes):

=image /effect/images/docs/tutorials/platformer/skyloop.jpg

In front of that, we have a layer of hills and some transparent clounds:

=passthrough
	<center><table cellspacing="5" cellpadding="0">
		<tr>
			<td class="checkers"><img src="/effect/api/view/games/tutorial1/assets/images/tiles/hills/a.png" width="320" height="320" style="border:1px solid #ccc;"/></td>
			<td class="checkers"><img src="/effect/api/view/games/tutorial1/assets/images/tiles/hills/b.png" width="320" height="320" style="border:1px solid #ccc;"/></td>
		</tr>
		<tr>
			<td class="grey"><img src="/effect/api/view/games/tutorial1/assets/images/tiles/hills/clouds_C.png" width="320" height="320" style="border:1px solid #ccc;"/></td>
			<td class="grey"><img src="/effect/api/view/games/tutorial1/assets/images/tiles/hills/clouds_B.png" width="320" height="320" style="border:1px solid #ccc;"/></td>
		</tr>
	</table></center>

The hill images seamlessly loop onto each other, and the cloud images loop onto themselves.  The clouds are shown on a grey background here, so you can see the alpha transparency.

=section #.#.#. Tiles

In front of the hills and clouds, we have the foreground tiles, at 32x32 pixels each.  Here they are:

=passthrough
	<center><table cellspacing="5" cellpadding="0"><tr>

	<td class="checkers"><img src="/effect/api/view/games/tutorial1/assets/images/tiles/foreground/dirt_C.png" width="32" height="32" style="border:1px solid #ccc;"/></td>
	<td class="checkers"><img src="/effect/api/view/games/tutorial1/assets/images/tiles/foreground/dirt_C2.png" width="32" height="32" style="border:1px solid #ccc;"/></td>
	<td class="checkers"><img src="/effect/api/view/games/tutorial1/assets/images/tiles/foreground/dirt_C3.png" width="32" height="32" style="border:1px solid #ccc;"/></td>
	<td class="checkers"><img src="/effect/api/view/games/tutorial1/assets/images/tiles/foreground/dirt_T.png" width="32" height="32" style="border:1px solid #ccc;"/></td>
	<td class="checkers"><img src="/effect/api/view/games/tutorial1/assets/images/tiles/foreground/dirt_B.png" width="32" height="32" style="border:1px solid #ccc;"/></td>
	<td class="checkers"><img src="/effect/api/view/games/tutorial1/assets/images/tiles/foreground/dirt_L.png" width="32" height="32" style="border:1px solid #ccc;"/></td>
	<td class="checkers"><img src="/effect/api/view/games/tutorial1/assets/images/tiles/foreground/dirt_R.png" width="32" height="32" style="border:1px solid #ccc;"/></td>
	<td class="checkers"><img src="/effect/api/view/games/tutorial1/assets/images/tiles/foreground/dirt_TL.png" width="32" height="32" style="border:1px solid #ccc;"/></td>
	<td class="checkers"><img src="/effect/api/view/games/tutorial1/assets/images/tiles/foreground/dirt_BL.png" width="32" height="32" style="border:1px solid #ccc;"/></td>
	<td class="checkers"><img src="/effect/api/view/games/tutorial1/assets/images/tiles/foreground/dirt_TR.png" width="32" height="32" style="border:1px solid #ccc;"/></td>
	<td class="checkers"><img src="/effect/api/view/games/tutorial1/assets/images/tiles/foreground/dirt_BR.png" width="32" height="32" style="border:1px solid #ccc;"/></td>
	<td class="checkers"><img src="/effect/api/view/games/tutorial1/assets/images/tiles/foreground/bluerock_C.png" width="32" height="32" style="border:1px solid #ccc;"/></td>
	<td class="checkers"><img src="/effect/api/view/games/tutorial1/assets/images/tiles/foreground/bluerock_C2.png" width="32" height="32" style="border:1px solid #ccc;"/></td>
	<td class="checkers"><img src="/effect/api/view/games/tutorial1/assets/images/tiles/foreground/bluerock_C3.png" width="32" height="32" style="border:1px solid #ccc;"/></td>
	<td class="checkers"><img src="/effect/api/view/games/tutorial1/assets/images/tiles/foreground/logvert_C.png" width="32" height="32" style="border:1px solid #ccc;"/></td>
	<td class="checkers"><img src="/effect/api/view/games/tutorial1/assets/images/tiles/foreground/logvert_T.png" width="32" height="32" style="border:1px solid #ccc;"/></td>

	</tr></table></center>

These tiles can be combined in the level editor to create custom, hybrid tiles.  For example, the grass top tile can be overlaid on the left and right egde pieces to create "corner" pieces, like this:

=passthrough
	<center><table cellspacing="5" cellpadding="0"><tr>
	<td class="checkers"><img src="/effect/api/view/games/tutorial1/assets/images/tiles/foreground/dirt_T.png?overlay=dirt_L.png" width="32" height="32" style="border:1px solid #ccc;"/></td>
	<td class="checkers"><img src="/effect/api/view/games/tutorial1/assets/images/tiles/foreground/dirt_T.png?overlay=dirt_R.png" width="32" height="32" style="border:1px solid #ccc;"/></td>
	</tr></table></center>

=section #.#.#. Tile Overlays

In addition to combining several tiles together to create hybrid tiles, we'll use a set of "overlay" tiles to create a raised 3D effect on certain rock tiles, and for decorations such as some plants:

=passthrough
	<center><table cellspacing="5" cellpadding="0"><tr>
	<td class="grey"><img src="/effect/api/view/games/tutorial1/assets/images/tiles/foreground/hemboss_TL.png" width="32" height="32" style="border:1px solid #ccc;"/></td>
	<td class="grey"><img src="/effect/api/view/games/tutorial1/assets/images/tiles/foreground/hemboss_T.png" width="32" height="32" style="border:1px solid #ccc;"/></td>
	<td class="grey"><img src="/effect/api/view/games/tutorial1/assets/images/tiles/foreground/hemboss_TR.png" width="32" height="32" style="border:1px solid #ccc;"/></td>
	<td class="grey"><img src="/effect/api/view/games/tutorial1/assets/images/tiles/foreground/hemboss_BL.png" width="32" height="32" style="border:1px solid #ccc;"/></td>
	<td class="grey"><img src="/effect/api/view/games/tutorial1/assets/images/tiles/foreground/hemboss_B.png" width="32" height="32" style="border:1px solid #ccc;"/></td>
	<td class="grey"><img src="/effect/api/view/games/tutorial1/assets/images/tiles/foreground/hemboss_BR.png" width="32" height="32" style="border:1px solid #ccc;"/></td>
	<td class="checkers"><img src="/effect/api/view/games/tutorial1/assets/images/tiles/foreground/plants1.png" width="32" height="32" style="border:1px solid #ccc;"/></td>
	<td class="checkers"><img src="/effect/api/view/games/tutorial1/assets/images/tiles/foreground/plants2.png" width="32" height="32" style="border:1px solid #ccc;"/></td>
	<td class="checkers"><img src="/effect/api/view/games/tutorial1/assets/images/tiles/foreground/plants3.png" width="32" height="32" style="border:1px solid #ccc;"/></td>
	</tr></table></center>

Some of these are shown with a grey background, so you can see the highlights and shadows.  For example, placing these on top of a rectangle of solid rock tiles creates a nifty effect:

=passthrough
	<center>
		<img src="/effect/api/view/games/tutorial1/assets/images/tiles/foreground/bluerock_C.png?overlay=hemboss_TL.png" width="32" height="32" style="margin:0; padding:0;"/>
		<img src="/effect/api/view/games/tutorial1/assets/images/tiles/foreground/bluerock_C.png?overlay=hemboss_T.png" width="32" height="32" style="margin:0; padding:0;"/>
		<img src="/effect/api/view/games/tutorial1/assets/images/tiles/foreground/bluerock_C.png?overlay=hemboss_TR.png" width="32" height="32" style="margin:0; padding:0;"/>
		<br/>
		<img src="/effect/api/view/games/tutorial1/assets/images/tiles/foreground/bluerock_C.png?overlay=hemboss_L.png" width="32" height="32" style="margin:0; padding:0;"/>
		<img src="/effect/api/view/games/tutorial1/assets/images/tiles/foreground/bluerock_C.png" width="32" height="32" style="margin:0; padding:0;"/>
		<img src="/effect/api/view/games/tutorial1/assets/images/tiles/foreground/bluerock_C.png?overlay=hemboss_R.png" width="32" height="32" style="margin:0; padding:0;"/>
		<br/>
		<img src="/effect/api/view/games/tutorial1/assets/images/tiles/foreground/bluerock_C.png?overlay=hemboss_BL.png" width="32" height="32" style="margin:0; padding:0;"/>
		<img src="/effect/api/view/games/tutorial1/assets/images/tiles/foreground/bluerock_C.png?overlay=hemboss_B.png" width="32" height="32" style="margin:0; padding:0;"/>
		<img src="/effect/api/view/games/tutorial1/assets/images/tiles/foreground/bluerock_C.png?overlay=hemboss_BR.png" width="32" height="32" style="margin:0; padding:0;"/>
		<br/>
	</center>

By keeping the overlay tiles separate, we can apply them to any tile later on.  The Level Editor has an "Overlay" option when drawing tiles, so we can overlay any number of tiles on top of each other, without having to add new layers.  The Effect Engine automatically handles superimposing the tiles images on the server, and it delivers all the unique combinations to the browser when the level is loaded, so we can use this technique extensively without taking any performance hit.

=section #.#.#. Player Sprite

Our main character can run around, jump, and throw rocks.  He is 50x70 pixels in size, except for some special cases like dying.  Here are all the animation frames we'll use:

=image /effect/api/view/games/tutorial1/assets/images/sprites/character/running.png class="checkers"
=caption Running.

=image /effect/api/view/games/tutorial1/assets/images/sprites/character/jumping.png class="checkers"
=caption Jumping.

=image /effect/api/view/games/tutorial1/assets/images/sprites/character/standing.png class="checkers"
=caption Standing and Misc.

=image /effect/api/view/games/tutorial1/assets/images/sprites/character/throwing.png class="checkers"
=caption Throwing a rock.

=image /effect/api/view/games/tutorial1/assets/images/sprites/character/death.png class="checkers"
=caption Dying.

Notice that we are storing multiple frames of animation in a single image.  This is the recommended way to store animation frames, because the engine can shift between visible positions in an image faster than it can switch between different images.  Meaning, you set your sprite size to the width and height of a single frame, but load an image that is much larger.  Then you can change frames easily in code (details below).

So, we're going to need these "flipped horizontally" so the character can face in both directions.  Manually make copies of all assets flipped?  No need.  Just select the "Mirror Horiz" transform in the Sprite definition (details below), and the engine does this for you automatically, non-destructively, as the images are loaded for use in your game.  Example:

=image /effect/api/view/games/tutorial1/assets/images/sprites/character/running.png?filter=fliph class="checkers"
=caption Running with "Mirror Horiz" transform applied.

Here is the rock we throw:

=image /effect/api/view/games/tutorial1/assets/images/sprites/character/rock.png class="checkers"

=section #.#.#. Enemies

We're going to have one ground based enemy, and one flying enemy.  For the ground, we'll have a potato bug that will walk around and bounce off walls:

=image /effect/api/view/games/tutorial1/assets/images/sprites/potato_bug.png class="checkers"
=caption Potato Bug.

For the air, we'll have a raven that will fly across the screen:

=image /effect/api/view/games/tutorial1/assets/images/sprites/raven.png class="checkers"
=caption Raven.

We'll apply the "Mirror Horiz" transform to these as well:

=image /effect/api/view/games/tutorial1/assets/images/sprites/potato_bug.png?filter=fliph class="checkers"
=caption Potato Bug with "Mirror Horiz" transform applied.

=image /effect/api/view/games/tutorial1/assets/images/sprites/raven.png?filter=fliph class="checkers"
=caption Raven with "Mirror Horiz" transform applied.

=section #.#.#. Misc Objects

Our character should have something to collect for points, so let's have some "crystals" placed throughout the level:

=image /effect/api/view/games/tutorial1/assets/images/sprites/crystal_med.png class="checkers"
=caption Crystal.

And a "sparkle" effect when the character picks up a crystal (shown on a grey background for visibility):

=image /effect/api/view/games/tutorial1/assets/images/sprites/sparkle.png class="grey"

And a few trees to scatter about the level:

=image /effect/api/view/games/tutorial1/assets/images/sprites/tree.png class="checkers"

=image /effect/api/view/games/tutorial1/assets/images/sprites/tree2.png class="checkers"

=image /effect/api/view/games/tutorial1/assets/images/sprites/tree3.png class="checkers"

Finally, a "checkpoint", which saves your progress for respawning:

=image /effect/api/view/games/tutorial1/assets/images/sprites/rod.png class="checkers"

=section #.#.#. Fonts

We'll be using a Bitmap Font for our heads-up display, showing the player's status, rocks, crystals, etc.  Here is that font image (shown against a grey background so you can see it properly).

=image /effect/images/docs/tutorials/platformer/font.png class="grey"

See [Adding a Heads-Up Display] below for details on this.

=section #.#. Tilesets

We will need two Tilesets for this game.  The first one will hold the background hills and transparent cloud overlay tiles, and be named "Hills".  The Tileset editor looks like this:

=image /effect/images/docs/tutorials/platformer/tileset_hills.png

The second Tileset will hold all our foreground tiles, and will be named "Foreground":

=image /effect/images/docs/tutorials/platformer/tileset_foreground.png

We don't need to check the "Preload" checkbox here, because we'll be assigning these Tilesets to layers in a level, which automatically loads them as needed.

=section #.#. Tile Class Setup

Tile classes need to be declared in the web interface, as well as in code.  We only need two tile classes for this demo, "{Ground}" and "{Stone}".

=image /effect/images/docs/tutorials/platformer/tile_classes.png

These will simply be set as "{solid}" to allow the built-in collision detection system to correct positions of sprites when colliding.  The only reason we need two classes is for different "footstep" sound effects on each type of tile.  More details can be found below.

=section #.#. Sprite Class Setup

Sprite classes need to be declared in the web interface, as well as in code.  Here are the various sprite classes we have:

=image /effect/images/docs/tutorials/platformer/sprite_classes.png

A quick example of each:

=deflist
	Character | Our main character sprite.  This can be placed into the level editor, marking the "starting position".
	Checkpoint | A checkpoint sprite.  If the character touches one of these, he'll respawn here after dying.
	Crystal | A crystal our player can pick up.  These will be placed at varios points throughout the level.
	Feather | When the Raven enemy is killed, it throws out some of these feathers.  These are *not* placed into levels, but are dynamically generated.
	NewGameButton | This button lives on the title screen, and starts a new game when clicked.
	PotatoBug | One of our enemy sprites.  This bug walks around and bounces off walls.  You can hit him with rocks.
	Raven | This is a flying enemy, which you can hit with rocks.
	Rock | This is a projectile weapon your player can throw at enemies.
	Sparkle | This is a sparkle which is left behind 
	Tree | This is a static tree sprite that just sits in the level and looks pretty.
	Tree2 | This one too.
	Tree3 | This one three.

You can see that some of these sprites have "Dependencies", meaning that when they are loaded, additional sprites will be loaded as well.  For example, the Character depends on the "Rock" sprite.  The Raven depends on the "Feather" sprite.  This dependency chain is created because only some sprites are placed into the level (and thus, automatically loaded).  For the sprites that are not, they have to be listed as dependencies of loaded sprites.  Alternatively, you can just check the "Preload" checkbox on these sprites, so they are loaded immediately when the engine starts up.

Each of the sprites also list one or more "Resources" which are loaded.  Resources could be images (like, the image that make up the sprite), sounds, music, or XML data files.  In our case, we're just loading images and sounds.

=section #.#. Level Setup

Okay, to setup our level, we have to give it a name, enter the size, and a few other options:

=image /effect/images/docs/tutorials/platformer/level_info.png

Next we just need to assign the background image, and define the layers.  

=section #.#.#. Background Image

For the background (sky + clouds) seamless image, we'll set the following options:

=image /effect/images/docs/tutorials/platformer/bkgnd_setup.png

Notice that the horizontal scrolling behavior is set to "Infinite Repeat", but the vertical behavior is "Fit To Level".  This is because the background image seamlessly loops in a horizontal direction, so we can have the level as wide as we want.  But, we cannot repeat the sky images vertically and have them look correct.  So we'll limit the level height to 5 screens or so, and when the virtual camera scrolls around the level, the background image will be moved so that it "fits" exactly into the level vertically.

=section #.#.#. Layers

We'll define three layers for the level, with these settings:

=image /effect/images/docs/tutorials/platformer/layers_setup.png style="border:0"

The "{hills}" layer is an intermediate tile layer between the sky background image and the foreground tiles.  It scrolls at 0.5X (50%) speed of normal, creating a parallax effect (the sky background scrolls even slower at 0.25X, further enhancing the effect).  These are large, 320x320 tiles from the "Hills" tileset we defined earlier.

The "{tiles}" layer is our foreground tile layer, which contains the main level graphics.  These are small, 32x32 pixel tiles from the "Foreground" Tileset.

Finally, the "{sprites}" layer is our foreground sprites layer, which holds our character, enemies, and various other sprites.  Keep in mind that while we have the layer's "Z-Index" property set at 3 (above everything else), each individual sprite may customize its z-index, if it wants.  The layer Z-Index is just the sprite default.

=section #.#.#. Sprite Dependencies

Listing sprites as a dependencies for a level is only needed in certain cases.  For example, if you place sprites into the level using the Level Editor, they will automatically be loaded.  If those sprites have dependencies listed, they will also be loaded.  If any tile classes placed in the level have sprite dependencies, they will also be loaded.  So the |only| time you ever need to list sprites as |level| dependencies, is when the sprite gets dynamically created in code, and no other sprites or tiles list the sprite as a dependency.

=image /effect/images/docs/tutorials/platformer/level_dependencies.png style="border:0"

In this case, we have only listed the "{Raven}" sprite as a dependency.  This is because the ravens are randomly generated enemies, and are not explicitly placed into the level.  More on this below.

=section #.#.#. Level Resources

For level resources the same rule applies: you only need to list things that are not already listed as resources of sprites and tiles that are automatically loaded.  In our case, we just need to load our background music track:

=image /effect/images/docs/tutorials/platformer/level_res.png style="border:0"

=section #.#.#. Level Properties

There are many possible uses for level properties, but for this simple game we just need to specify which music track to play (so each level can have its own music track).  First, we define a "{music}" property on the "Levels" tab:

=image /effect/images/docs/tutorials/platformer/level_prop_defs.png style="border:0"

Then we assign our music track filename to the property for our level:

=image /effect/images/docs/tutorials/platformer/level_props.png style="border:0"

We'll see how to load and play the music track below.

=section #.#.#. Level Map

For designing the level map, we simply have to draw in all our tiles and sprites where we want them.  Here is a screenshot of this happening:

=image /effect/images/docs/tutorials/platformer/level_map.png style="border:0"

So let's break this down by each layer, and isolating that layer (hiding the others) so you can see how it all comes together:

=section #.#.#.#. Background Layer

=image /effect/images/docs/tutorials/platformer/level_map_bkgnd.png

This is the background layer, which is simply a repeating image that we setup before.

=section #.#.#.#. Hills

=image /effect/images/docs/tutorials/platformer/level_map_hills.png

This is another background layer, in front of the sky but behind all our foreground graphics.  This is a tile layer, with large, 320x240 tiles we can place.  We have a few transparent cloud tiles, and some hills.  These scroll by slowly in the background.

=section #.#.#.#. Tiles

=image /effect/images/docs/tutorials/platformer/level_map_tiles.png

This is our main foreground tile layer, which contains all the main level graphics.  The tiles are 32x32 pixels, and we have some ground, grass, stone, and several "decorative" tiles that are superimposed on top of other tiles.  This is done by selecting the pencil "Overlay" option, which creates new "virtual" tiles by combining multiple tiles together.

=section #.#.#.#. Tile Data

=image /effect/images/docs/tutorials/platformer/level_map_tile_data.png

Our foreground tile layer has a "data layer" attached to it.  That means, not only does it hold visual tile graphics, but also "tile classes" for associating behavior with certain tiles.  For example, as you can see in the screenshot, we created a simple tile class named "Ground", and we have applied this to all the "solid" tiles we can stand on.

=section #.#.#.#. Sprites

=image /effect/images/docs/tutorials/platformer/level_map_sprites.png

And finally, we have our foreground sprites layer.  This is where we place sprites into the level, including our character, enemies, crystals, and trees.  These sprites are saved with the level, and automatically loaded and placed into the world as needed, when scrolled into view.

=section #.#. Game Setup Code

So let's dive into a little code.  We need to hook the [api:Effect.Game.onLoadGame] event and load our level.  Once our level is loaded, we can setup our layers and player sprite:

=syntax js
	Effect.Game.addEventListener( 'onLoadGame', function() {
		// game engine is ready
		
		// load our level
		Effect.Game.loadLevel( 'Level1', function() {
			// level is loaded!
			
			// get references to our planes, which were created automatically for us
			var splane = Effect.Port.getPlane('sprites');
			var tplane = Effect.Port.getPlane('tiles');
			
			// connect the two foreground planes together, for collision detection
			splane.linkTilePlane( tplane );
			
			// locate our player sprite and scroll to his position
			var player = splane.getSprite( 'player' );
			Effect.Port.follow( player );
			
			// save his current location for respawning
			player.respawnX = player.x;
			player.respawnY = player.y;
		} );
	} );

Just in case it isn't clear, there are |two| asynchronous calls being made here, and both are specifying inline anonymous functions (i.e. closures) for executing code when the actions complete.  The first inline function will be called when the engine completes loading.  Then we request to load our level, and specify a second function for execution when the level is loaded, activated and ready to play.

To prepare the level to be played, we have to connect our two foreground planes using [api:SpritePlane.linkTilePlane()].  This is so when we perform sprite collision detection, the tile plane will also be considered (our tile plane has a data layer, for specifying which tiles are "solid ground", etc.).

Next we locate our player sprite which was loaded with the level.  This sprite definition is flagged to be "Always Active", meaning it will be placed into the world regardless of where the screen is scrolled.  This way we can locate it easily by a simple call to [api:SpritePlane.getSprite()] and passing its globally unique ID "{player}" which we set in the level editor.

We have to do a little keyboard setup here too.  Our character sprite handles most of our keyboard handling (movement, jumping, throwing rocks, etc.), but we also have a "pause" key which we want to pause and resume the engine.  To support this, we need to hook the event:

=syntax js
	// Hook the 'start' key for pausing and resuming the game
	Effect.Game.setKeyHandler('start', {
		onKeyDown: function() {
			Effect.Game.pause();
		}
	} );
	Effect.Game.setResumeKey( 'start' );

So here we are setting a handler object for the "{start}" key control, and giving it an "{onKeyDown}" method.  All this has to do is call [api:Effect.Game.pause()].  But what about resuming the game?  Well the thing is, when the engine is paused, it no longer fires our keyboard event handlers, so we have to call [api:Effect.Game.setResumeKey()] so the engine knows to map our "{start}" key to also |resume| the engine if it is paused.

Please note that [api:Effect.Game.setKeyHandler()] cannot be called until the game is loaded.  So place this code inside your [api:Effect.Game.onLoadGame] handler.

=section #.#. Tiles

So, as you saw earlier, we defined two tile classes, "Ground" and "Stone", which we applied to certain tiles in the level editor.  Now we have to write a little code to handle these tiles, matching the class names exactly:

=syntax js
	// The 'Ground' tile class represents solid ground or walls
	Tile.extend( 'Ground', {
		collisions: true,
		solid: true
	} );
	
	// The 'Stone' class is the same as 'Ground', but has different sfx for walking on
	Tile.extend( 'Stone', {
		collisions: true,
		solid: true
	} );

All we're doing here is defining the classes, enabling collision detection by the [api:Tile.collisions] property, and marking them as solid by the [api:Tile.solid] property.  Why do we need two if they are identical?  Check out [Adding Sound Effects and Music] below.

=section #.#. Sprites

Now let's take a look at some of our sprite classes, and the code to handle them.

=section #.#.#. Trees

We have a number of trees in the demo, which are just static images that don't have any handling code.  However, we still have to declare the classes, so the engine knows how big they are, which image to display, and most importantly, to *not* consider them for collision detection.  Here are our three tree classes:

=syntax js
	Sprite.extend( 'Tree', {
		width: 480,
		height: 320,
		url: '/images/sprites/tree.png',
		collisions: false
	} );

	Sprite.extend( 'Tree2', {
		width: 300,
		height: 320,
		url: '/images/sprites/tree2.png',
		collisions: false
	} );

	Sprite.extend( 'Tree3', {
		width: 64,
		height: 93,
		url: '/images/sprites/tree3.png',
		collisions: false
	} );

That's all we have to do for the trees.  Now, onto more interesting sprites:

=section #.#.#. Character Sprite

By far our most complicated sprite is the "{Character}" sprite, which handles our player and his actions.  This sprite handles key presses, switches states and images, and even changes size.  Check out the following sections for details.

=section #.#.#.#. Setup

First let's declare our class, property defaults and a [api:Sprite.setup()] method:

=syntax js
	// Our Character sprite
	Sprite.extend( 'Character', {
		width: 50,
		height: 70,
		url: '/images/sprites/character/jumping.png',
		collisions: true,
		hitRect: new Rect( 10, 6, 40, 70 ),
		frameX: 1,
		
		// custom properties:
		state: 'falling',
		facingLeft: false,
		requestJump: false,
		requestThrow: false,
		crystals: 0,
		energy: 5,
		rocks: 99,
		invincibleTimer: 0,
		
		setup: function() {
			// hook the 'jump' and 'shoot' keys to make us jump or throw a rock
			// these are different than left/right keys because these are one-time events.
			// i.e. we don't want to "miss" the event if the player taps the key between frames
			// with moving you can just hold the keys down, and check for that
			this.setKeyHandler( 'jump', 'shoot' );
		}
	} );

So here we are setting some built-in properties, adding some of our own custom properties, and a {setup()} method.  The built-in properties are covered in the [article:docs/Getting Started Guide] and [article:docs/Sprites and Tiles Guide], but here are descriptions of our custom properties:

=deflist
	state | This sets our current "state", which is explained below.
	facingLeft | Our character can face either left or right, so we keep this flag to know which way we are currently facing.
	requestJump | This is a flag indicating that the user pressed the "jump" key, and is explained below.
	requestThrow | This is a flag indicating that the user pressed the "shoot" key, and is explained below.
	crystals | This is a counter which holds our current number of crystals (we pick these up throughout the level).
	energy | This is our current energy (number of hearts).  When this hits zero, we die.
	rocks | This is our current number of rocks.  If we run out, we cannot throw any more.
	invincibleTimer | Whenever we take damage from an enemy, we'll be "invincible" for a few seconds, and this timer controls that.

For the {setup()} method, we are simply hooking two keyboard events, so we can know the instant the user presses the "jump" or "shoot" keys.  You may notice that we're not hooking the movement keys here, and that is because we can just call [api:Effect.Game.isKeyDown()] for those.  But jumping and shooting are "immediate" events, so we don't want to "miss" a keyDown if the frame rate is too slow and the user is too fast.

We also have to define an {onKeyDown()} function to handle receiving key events:

=syntax js
	Character.add({
		onKeyDown: function(key) {
			// receive keyDown event
			// this can fire between logic frames, so we just set a flag here, allowing
			// the next logic frame to pick up the request for a jump or throw.
			if ((key == 'jump') && ((this.state == 'running') || (this.state == 'standing'))) {
				this.requestJump = true;
			}
			else if ((key == 'shoot') && ((this.state == 'running') || (this.state == 'standing') || (this.state == 'falling'))) {
				this.requestThrow = true;
			}
		}
	} );

As you can see, we are only setting the flag if the player is in the correct "state" for the situation.  For example, we only allow jumping if the player is standing or running (i.e. you can't jump while falling).  And we only allow throwing rocks while running, standing or falling.  These different player "states" are described in detail below.

=section #.#.#.#. Logic

Here is our sprite [api:Sprite.logic()] method, which is called once for every iteration through the main logic loop:

=syntax js
	Character.add({
		logic: function(clock) {
			// call function named by our current state (i.e. falling, running)
			this[ this.state ](clock);
			
			// keep player within level bounds, regardless of state
			if (this.x < 0) this.x = 0;
			else if (this.x > this.port.virtualWidth - 50) this.x = this.port.virtualWidth - 50;
			
			// die if he falls off the bottom
			if (this.y > this.port.virtualHeight) {
				// death from falling
				this.respawn();
			}
			
			// decrease invincible timer (hit by enemy)
			if (this.invincibleTimer) {
				this.invincibleTimer--;
				if (!this.invincibleTimer) this.show();
			}
			
			// automatically scroll the screen, following our player smoothly
			Effect.Port.follow( this, 0.125 );
		}
	} );

Our sprite uses a simple [wikipedia:State_machine finite-state machine] to handle a basic set of states.  We have [Running], [Falling] (which is also jumping), [Standing], [Throwing] and [Dying].  To accomplish this, we simply set a custom property in our sprite class called "{state}" which is set to the name of the current state.  Then, we simply invoke the function by name, like this:

=syntax js
	// call function named by our current state (i.e. falling, running)
	this[ this.state ](clock);

We're passing along the logic clock (the logic frame counter), so we can control animation speed.  See [api:Effect.Game.logicClock] for details.

As you can see we also have some code |after| calling the specific state handler method.  We're limiting the character's position to the horizontal level boundaries (by comparing [api:Sprite.x] to [api:Effect.Port.virtualWidth]), so he can't run or fall outside the horizontal limits.  And vertically, we have him "die" if he falls off the bottom of the level.  We're assuming the player has infinite lives for this demo, so we just call a custom {respawn()} method (see [Respawning] below) to reset the characters position and stats.

Next, we check if our {invincibleTimer} is active, and if so, decrease it until it hits zero.  We also call [api:Sprite.show()] here, in case we were in the middle of a "blink" when the timer ran out.  To explain further, please see [Draw Override] below.

Finally, we call [api:Effect.Port.follow()] so the "virtual camera" follows our player sprite around the level.  We pass in a reference to our sprite object, and a value that sets the "speed" of the camera.

=section #.#.#.#.#. Running

=image /effect/api/view/games/tutorial1/assets/images/sprites/character/running.png class="checkers"

Here is our method for handling the "{running}" state:

=syntax js
	Character.add({
		running: function(clock) {
			// running
			// animate frames based on speed of motion
			var frameMod = 0;
			var ourSpeed = Math.abs(this.xd);
			
			if (ourSpeed < 2) frameMod = 24; // slow
			else if (ourSpeed < 4) frameMod = 12; // medium
			else if (ourSpeed < 8) frameMod = 7; // fast
			else frameMod = 5; // cheetah
			
			if (clock % frameMod == 0) {
				// advance frame
				if (this.facingLeft) {
					this.setFrameX( this.frameX - 1 );
					if (this.frameX < 7) this.setFrameX( 13 );
				}
				else {
					this.setFrameX( this.frameX + 1 );
					if (this.frameX > 6) this.setFrameX( 0 );
				}
			}
			
			// set run direction and speed based on arrow keys
			if (Effect.Game.isKeyDown('right')) {
				if (this.xd < 8) this.xd += 0.3;
			}
			else if (Effect.Game.isKeyDown('left')) {
				if (this.xd > -8) this.xd -= 0.3;
			}
			else {
				// no keys held, slow us down
				this.xd *= 0.8;
			}
			
			// flip player's direction to match horiz delta
			if (this.facingLeft && (this.xd > 0)) {
				this.facingLeft = false;
				this.setFrameX( 13 - this.frameX );
			}
			else if (!this.facingLeft && (this.xd < 0)) {
				this.facingLeft = true;
				this.setFrameX( 13 - this.frameX );
			}
			
			// now move the sprite, horizontal only first
			var hit = this.move( this.xd, 0 );
			if (hit) {
				// if we hit something solid, stop our horiz movement
				if (hit.target.solid) this.xd = 0;
				this.handleHit( hit );
			}
			
			// gravity check
			hit = this.move( 0, 1 );
			if (!hit || !hit.target.solid) {
				// nothing under us!  we're falling!
				this.state = 'falling';
				this.setImage( 'jumping.png' );
				this.setFrameX( this.facingLeft ? 14 : 1 );
				this.yd = 1;
				return;
			}
			
			if (this.requestJump) {
				this.jump();
				return;
			}
			else if (this.requestThrow) {
				this.throw_rock();
				return;
			}
			
			if (!Effect.Game.isKeyDown('left') && !Effect.Game.isKeyDown('right') && (Math.abs(this.xd) <= 1)) {
				// motion has stopped, go to standing
				this.xd = 0;
				this.yd = 0;
				this.state = 'standing';
				this.setImage( 'standing.png' );
				this.setFrameX( this.facingLeft ? 25 : 4 );
				return;
			}
		}
	} );

First, we are setting the animation frames using [api:Sprite.setFrameX()] based on our current speed ([api:Sprite.xd]).  We want our legs to move slowly at first, then pick up speed as we continue to hold down the "{left}" or "{right}" control keys.  To control this animation speed, we use the game's logic clock ([api:Effect.Game.logicClock]), which is ever-increasing at a constant rate.  Using this we can perform modulus (remainder of integer division) to advance the animation every frame, every other frame, every 3rd frame, and so on.

Next, we are increasing or decreasing our speed ([api:Sprite.xd]) based on which keys are being held down (using [api:Effect.Game.isKeyDown()]).  If the "{right}" key is held down we increment our delta, if the "{left}" key is down we decrement it, and if neither key is down, we come to a stop.  We also have a maximum horizontal delta of "{8}" (or "{-8}" if running to the left) which we enforce (the character's maximum run speed).

Next we check the player's direction (which way he is facing) based on our horizontal movement.  If we are heading left but facing right (or visa-versa), we immediately turn around (this is done simply by changing the animation frame via [api:Sprite.setFrameX()]).

Next comes actual movement and collision detection.  We are using the built-in [api:Sprite.move()] function, which handles moving our sprite, checking collisions, and reporting back what we ran into, if anything.  We split this up into two calls: horizontal movement, then vertical movement (so we can tell if we hit a wall to our sides, or hit ground below us).

First we move horizontally.  If we hit anything solid, we simply set our [api:Sprite.xd] property to "{0}", stopping our horizontal movement immediately.  We also call a custom method called {handleHit()} in case we hit a sprite (see [Handling Hits] below).

Next we perform a "gravity check".  Since we are running along the ground here, we could run right off a ledge, and if that happens, we need to immediately switch to a "{falling}" state.  So what we do is move our character 1 pixel downward, and check to see what we hit (if we hit solid ground, the engine auto-corrects our sprite's position).  If there is nothing under our feet, we switch states to "{falling}".  As you can see, switching states involves simply setting our custom "{state}" property, changing our image via [api:Sprite.setImage()], and setting the animation frame via [api:Sprite.setFrameX()].

After movement is complete (and we're still in a "{running}" state), we check to see if the user wants to jump, or throw a rock.  We are querying our custom "{requestJump}" and "{requestShoot}" properties here, which will be {true} if the user pressed the key anytime since the last logic loop (this way we don't miss any quick key taps).  Since these actions can take place in multiple states, we have utility methods for initiating a jump ({jump()}), and initiating a throw ({throw_rock()}).  Here is the {jump()} method:

=syntax js
	Character.add({
		jump: function() {
			// let's jump!  just set our state to "falling" with an upward direction
			// gravity will send us back down very soon
			this.state = 'falling';
			this.setImage( 'jumping.png' );
			this.setFrameX( this.facingLeft ? 14 : 1 );
			this.yd = -12;
			this.requestJump = false;
			this.hitRect.top = 15;
		}
	} );

As you can see, we don't actually have a "{jumping}" state.  We are just re-using the "{falling}" state for a jump, but setting our vertical delta ([api:Sprite.yd]) to "{-12}", which sends us flying upward.  As you will see in the [Falling] state below, gravity is always pulling us down, so we simply come to a stop in the air, and begin to fall.  By contrast, if we are switching from a running state directly to a falling state (i.e. running off a ledge), we instead set the vertical delta to "{1}", beginning our descent immediately.

Also note here, we are changing the "{top}" property of our [api:Sprite.hitRect].  This is because our player actually changes his effective "height" when jumping, because he clutches he knees.  So when jumping, we "shrink" our collision detection "bounding box" by a bit, for more realistic collisions.  When we land on the ground again, this will be reset to its normal value.

Finally, if we were running then just "let go" of the controls, we need to come to a stop, and switch over to the "{standing}" state.  This is done by checking if no movement keys are down, and our absolute horizontal delta is less than "{1.0}", we switch states.

=section #.#.#.#.#. Falling

=image /effect/api/view/games/tutorial1/assets/images/sprites/character/jumping.png class="checkers"

Here is our method for handling the "{falling}" state (which is also used for jumping):

=syntax js
	Character.add({
		falling: function(clock) {
			// advance animation frame until player is clutching his knees
			if (clock % 2 == 0) {
				if (this.facingLeft) {
					if (this.frameX > 8) this.setFrameX( this.frameX - 1 );
				}
				else {
					if (this.frameX < 7) this.setFrameX( this.frameX + 1 );
				}
			}
			
			// set our direction and velocity based on arrow keys
			if (Effect.Game.isKeyDown('right') && (this.xd < 8)) this.xd += 0.3;
			else if (Effect.Game.isKeyDown('left') && (this.xd > -8)) this.xd -= 0.3;
			else this.xd *= 0.8;
			
			// gravity is always pullin' us down
			if (this.yd < 8) this.yd += 0.5;
			
			// we can change direction in mid-air, sure
			if (this.facingLeft && (this.xd > 0)) {
				this.facingLeft = false;
				this.setFrameX( 15 - this.frameX );
			}
			else if (!this.facingLeft && (this.xd < 0)) {
				this.facingLeft = true;
				this.setFrameX( 15 - this.frameX );
			}
			
			// now move the sprite, horizontal only first
			var hit = this.move( this.xd, 0 );
			if (hit) {
				// if we hit something solid, stop our horiz movement
				if (hit.target.solid) this.xd = 0;
				this.handleHit( hit );
			}
			
			// now move vertically
			hit = this.move( 0, this.yd );
			if (hit) {
				// if we hit something solid, stop our vert movement
				if (hit.target.solid) {
					if (this.yd > 0) {
						// player was falling downward, so we hit solid ground
						if (Math.abs(this.xd) > 1) {
							// player is in motion, go straight to running
							this.state = 'running';
							this.setImage( 'running.png' );
							this.setFrameX( this.facingLeft ? 13 : 0 );
						}
						else {
							// player is idle, go to standing
							this.state = 'standing';
							this.setImage( 'standing.png' );
							this.setFrameX( this.facingLeft ? 29 : 0 );
						}
						this.hitRect.top = 6;
					}
					this.yd = 0;
				} // hit solid
				this.handleHit( hit );
			} // hit something
			
			if (this.requestThrow) {
				this.throw_rock();
				return;
			}
		}
	} );

First, we control the falling animation.  Our character clutches his knees while falling, so we advance the animation frame until we hit the end of the animation, and hold there (until we hit solid ground).  Once again we are using the game's logic clock ([api:Effect.Game.logicClock]), and performing a modulus of 2 to advance every other frame.

Next we allow the user to control his position in mid-air (not realistic, but provides a better gaming experience).  Just like in the [Running] state, we increase or decrease the [api:Sprite.xd] property based on whether the "{left}" or "{right}" keys are held down, or if neither are, we come to a horiztonal "stop" and fall straight down.

After that we handle gravity.  We aren't going for super-realism here, just a constant vertical pull will do the trick.  So we are constantly increasing the vertical delta ([api:Sprite.yd]) until it reaches "{8}" (assuming this is terminal velocity in our world).  This works if our delta is negative (i.e. jumping), or neutral (ran off a ledge).

Same as in the "{running}" state, we can change direction in mid air, so we have to "flip" our direction if we need to.  So if we are facing right, but are now moving in a negative horizontal direction (or visa versa), we flip around, and set our [api:Sprite.frameX] accordingly.

Now we handle movement and collision detection.  First, we move horizontally, and check to see if we ran into anything solid (walls).  If so, no problem, we just set our horizontal delta to "{0}".  We also check our custom {handleHit()} method, in case we ran into a sprite (see [Handling Hits]) below.

After horiztonal movement, we go vertical.  Once again we call [api:Sprite.move()], and check the results.  Hitting something |below| us here is a big deal, because we are currently "{falling}", so we check our vertical delta, and if it is positive (heading downward), we have to switch to a "{running}" or "{standing}" state.  Notice that we also reset our [api:Sprite.hitRect] here to a more proper value for standing upright.  We also check our custom {handleHit()} method, in case we ran into a sprite (see [Handling Hits]) below.

Finally, we allow the player to throw rocks while falling, so we check for our custom "{requestThrow}" property, and if {true}, we call our custom "{throw_rock()}" method (described below).

=section #.#.#.#.#. Standing

=image /effect/images/docs/tutorials/platformer/character_standing.png class="checkers"

Here is our method for handling the "{standing}" (i.e. idle) state:

=syntax js
	Character.add({
		standing: function(clock) {
			// standing still
			if (Math.abs(this.xd) < 1) this.xd = 0;
			else this.xd *= 0.5;
			
			// may be recovering from fall, so animate frames
			if (clock % 2 == 0) {
				if (this.facingLeft) {
					if (this.frameX > 25) this.setFrameX( this.frameX - 1 );
				}
				else {
					if (this.frameX < 4) this.setFrameX( this.frameX + 1 );
				}
			}
			
			if (this.requestJump) {
				this.jump();
				return;
			}
			else if (this.requestThrow) {
				this.throw_rock();
				return;
			}
			
			if (Effect.Game.isKeyDown('right') || Effect.Game.isKeyDown('left')) {
				if (Effect.Game.isKeyDown('right')) {
					this.xd = 1;
					this.facingLeft = false;
				}
				else {
					this.xd = -1;
					this.facingLeft = true;
				}
				this.state = 'running';
				this.setImage( 'running.png' );

				// randomly choose whether to start on the left or right foot (for some variety)
				if (probably(0.5)) this.setFrameX( this.facingLeft ? 10 : 3 );
				else this.setFrameX( this.facingLeft ? 13 : 0 );

				// to prevent "flickering" between running and standing, we call running() now.
				// so if the player is trying to run into a wall, running() will set the
				// state and image back to "standing" before the draw loop fires.
				this.running(clock);
			}
		}
	} );

So, not only does this state handle standing idle, but it also handles "recovery from a fall".  We have a few frames of animation for the character landing, and bending his knees, before coming back up to an idle, upright position.  So we check our animation frame, and keep advancing it until it hits our "idle" frame, and then hold there.  Also, we may have entered this state with a lingering horiztonal delta (such as landing diagonally), so we have to reduce our [api:Sprite.xd] property until it reaches zero.

Next, we check for a jump or throw request by examining our custom "{requestJump}" and "{requestThrow}" properties.  If any are {true}, we immediately switch states and initiate the action requested.

Finally, we have to handle "leaving" the idle state by way of movement.  If the player presses either the "{left}" or "{right}" keys, we switch states to "{running}".  We also handle switching directions here, if the character is facing right, but wants to run left (or visa-versa).

One tricky thing we are doing here, is we are actually calling our "{running()}" function directly from within our "{standing()}" method.  This is unusual, because the next time around the logic loop, the "{running()}" method will be called automatically.  However, we need to handle the case where the player is right up against a wall, and tries to run straight into it.  We want to "catch" this, and immediately return to a "{standing}" state, and not "flicker" between the two states.  Alternatively, this could be handled by "pre-moving" the character by 1 pixel in the desired direction, and checking the result before changing states.  Either way, no flicker is good.

=section #.#.#.#.#. Throwing

=image /effect/api/view/games/tutorial1/assets/images/sprites/character/throwing.png class="checkers"

Our player can throw rocks at enemies, so we need a "{throwing}" state.  This state handles both throwing while standing / running, and throwing while in the air.  First, here is our custom "{throw_rock()}" method, which is called by the "{standing()}", "{running()}" or "{falling()}" methods when the player presses the "{shoot}" key:

=syntax js
	Character.add({
		throw_rock: function() {
			// throw a rock
			this.requestThrow = false;
			
			if (this.rocks > 0) {
				this.rocks--;
				
				this.setImage( 'throwing.png' );
				
				if (this.state == 'falling') {
					this.setFrameX( this.facingLeft ? 8 : 3 );
				}
				else {
					this.setFrameX( this.facingLeft ? 11 : 0 );
				}
				
				this.state = 'throwing';
				this.throwTimer = -1;
			}
		}
	} );

The first thing we do here is reset our custom "{requestThrow}" property to {false}, until the next time the player hits the key.  This way the player cannot simply hold down the "{shoot}" key to keep firing rocks.

Next, we check our custom "{rocks}" property, to make sure we have a rock in our inventory to throw.  If so, we decrement the counter by one, and initiate the throw.  This is done by changing our image via [api:Sprite.setImage()], then setting our animation frame, based on our previous state.  We have animation frames for throwing in the air, and on the ground.  We set it accordingly.  Then we set our state to "{throwing}", and set a custom "{throwTimer}" property to "{-1}" (this is explained below).

Here is our "{throwing()}" method for handling animating the player while in the "{throwing}" state:

=syntax js
	Character.add({
		throwing: function(clock) {
			// character is throwing a rock
			if ((this.throwTimer == -1) && (clock % 2 == 0)) {
				// preroll animation (character swinging arms)
				this.setFrameX( this.facingLeft ? (this.frameX - 1) : (this.frameX + 1) );
				switch (this.frameX) {
					case 2:
					case 5:
					case 6:
					case 9:
						// end of animation, create the rock sprite
						// you can control the trajectory of the rock by holding up or down while firing
						var rock_yd = -3;
						if (Effect.Game.isKeyDown('down')) rock_yd = 2;
						else if (Effect.Game.isKeyDown('up')) rock_yd = -8;

						this.plane.createSprite( 'Rock', {
							x: this.facingLeft ? (this.x - 16) : (this.x + 50),
							y: this.y + 8,
							xd: this.facingLeft ? -8 : 8,
							yd: rock_yd
						} );

						// set a timer so we hold on our last frame for a bit,
						// then go back to falling or standing
						this.throwTimer = 12;
						break;
				}
			}
			
			this.xd *= 0.8;
			
			// gravity is always pullin' us down
			if (this.yd < 8) this.yd += 1;
			
			// now move the sprite, horizontal only first
			var hit = this.move( this.xd, 0 );
			if (hit) {
				// if we hit something solid, stop our horiz movement
				if (hit.target.solid) this.xd = 0;
				this.handleHit( hit );
			}
			
			// now move vertically
			hit = this.move( 0, this.yd );
			var onSolid = false;
			
			if (hit) {
				// if we hit something solid, stop our vert movement
				if (hit.target.solid) {
					if (this.yd > 1) this.footstep(hit);
					if (this.yd > 0) {
						// if we're currently on the "throw in mid air" frames
						// switch to our "standing" frames, seeing as we are now
						// standing on solid ground
						if (this.frameX >= 3 && this.frameX <= 5) this.setFrameX( this.frameX - 3 );
						else if (this.frameX >= 6 && this.frameX <= 8) this.setFrameX( this.frameX + 3 );
					}
					this.yd = 0;
					onSolid = true;
				} // hit solid
				this.handleHit( hit );
			} // hit something
			
			if (this.throwTimer > 0) {
				this.throwTimer--;
				if (!this.throwTimer) {
					// all done with the throw, go back to a standard state
					if (onSolid) {
						// we're standing on solid ground, so to go 'standing' state
						this.xd = 0;
						this.yd = 0;
						this.state = 'standing';
						this.setImage( 'standing.png' );
						this.setFrameX( this.facingLeft ? 25 : 4 );
						this.requestJump = false;
						this.hitRect.top = 6;
					}
					else {
						// we're still in the air, so go to 'falling' state
						this.state = 'falling';
						this.setImage( 'jumping.png' );
						this.setFrameX( this.facingLeft ? 14 : 1 );
						this.requestJump = false;
						this.hitRect.top = 15;
					}
				}
			}
		}
	} );

First, we control the player's animation.  Our "throw" animation is three frames in length, so we animate until we hit the end.  Keep in mind that we may be facing left or right, and we could be throwing in the air, or on the ground.  So we actually have 4 different "ending" frames that mark the end of the animation.  When we hit that frame, we actually throw the rock.

Here we have our first example of dynamically creating a sprite:

=syntax js
	this.plane.createSprite( 'Rock', {
		x: this.facingLeft ? (this.x - 16) : (this.x + 50),
		y: this.y + 8,
		xd: this.facingLeft ? -8 : 8,
		yd: rock_yd
	} );

Using the [api:SpritePlane.createSprite()] method, we create a new "{Rock}" sprite, and position it right at our "fingertips".  We also sets its horiztontal and vertical direction, based on ours.  See [Rock Projectile] below for more on the Rock sprite.

Next we set a custom "{throwTimer}" property.  This is simply a frame counter, which "freezes" the frame on our final throw animation frame, just long enough for the player to notice (12 frames or so), then we change states back to "{falling}" or "{standing}".  See below.

After that we run all the basic movement and collision detection code, because the player may be in motion when he enters the "{throwing}" state.  We don't check for key presses during this animation, we just allow gravity to pull us down, and bring our horizontal delta slowly to a stop, if applicable.

The "{throwing}" state is actually a combination state handler, which deals with throwing a rock while standing on the ground, or in the air.  So we have to perform a few extra checks for special cases.  For example, if the user is falling, throws a rock, and then immediately hits solid ground while still throwing, we immediately "switch" over to our stand-throw animation frames (otherwise he looks silly).

Finally, we decrement our custom "{throwTimer}" counter, which holds our animation on the final frame, and then we have to switch states to something appropriate.  For this, we check the result of our last vertical movement, and if there is solid ground under us, we switch to the "{standing}" state.  Otherwise, we're still falling, so we go back to a "{falling}" state.

=section #.#.#.#.#. Dying

=image /effect/images/docs/tutorials/platformer/death1.png class="checkers"
=caption Death animation, part one.

=image /effect/api/view/games/tutorial1/assets/images/sprites/character/death.png class="checkers"
=caption Death animation, part two.

If the player takes too many hits from enemies and dies (see [Taking Pain] below), we switch to a "dying" state, where we simply fall over and lie dead.  However, we may have been killed in mid air, so we have to handle that case as well.  Here is the method for handling all this:

=syntax js
	Character.add({
		dying: function(clock) {
			// character is dying
			switch (this.deathPhase) {
				case 1:
					if (clock % 4 == 0) {
						// preroll animation (character falling over)
						this.setFrameX( this.facingLeft ? (this.frameX - 1) : (this.frameX + 1) );
						switch (this.frameX) {
							case 13:
							case 16:
								// end of first part of death animation
								// we'll "hold" this last frame until we are on solid ground
								// (in case we died in mid air)
								this.deathPhase = 2;
								break;
						} // switch frameX
					} // every 4th frame
					break;
					
				case 2:
					// waiting for collision detection to tell us we are on solid ground
					// then we move straight to phase 3.
					break;
					
				case 3:
					// final phase of death animation
					if (clock % 4 == 0) {
						if (this.facingLeft) {
							if (this.frameX > 3) this.setFrameX( this.frameX - 1 );
						}
						else {
							if (this.frameX < 2) this.setFrameX( this.frameX + 1 );
						}
					}
					break;
			}
			
			this.xd *= 0.8;
			
			// gravity is always pullin' us down
			if (this.yd < 8) this.yd += 1;
			
			// now move the sprite, horizontal only first
			var hit = this.move( this.xd, 0 );
			if (hit) {
				// if we hit something solid, stop our horiz movement
				if (hit.target.solid) this.xd = 0;
			}
			
			// now move vertically
			hit = this.move( 0, this.yd );
			if (hit) {
				// if we hit something solid, stop our vert movement
				if (hit.target.solid) {
					this.yd = 0;
					if (this.deathPhase == 2) {
						// switch to final phase of death animation
						// we have to change "size" to do this, because the 
						// frames are landscape-oriented (character is lying down)
						this.deathPhase = 3;
						this.width = 70;
						this.height = 50;
						this.y += 20; // adjust position due to height change
						this.hitRect.set( 10, 6, 60, 50 );
						this.setImage( 'death.png' );
						this.setFrameX( this.facingLeft ? 5 : 0 );
						
						// set timer to respawn character after a few seconds
						var player = this;
						Effect.Game.scheduleEvent( 150, function() { player.respawn(); } );
					}
				} // hit solid
			} // hit something
		}
	} );

The death animation is split up into three distinct "phases", controlled by the custom "{deathPhase}" property, which will be "{1}", "{2}" or "{3}".

=list
	In phase one, we animate through the first set of animation frames.  This happens whether the death occurred in mid air or on the ground.  Then, when the first animation frames run their course, we switch to phase two.
	In phase two, we "hold" on the final animation frame from the first set, until the player is on solid ground.  That way, if the player dies in the air, he will look "correct" while falling.  As soon as he hits the ground, we move to phase three.
	In phase three, we animate through the final set of frames, with the player ending up lying flat on his back.

After the animation control code, we proceed with basic movement and collision detection.  During this state, the player is constantly "falling" (whether he is on ground or not), so gravity is constantly pulling us down.  If we are already on the ground, no problem, the engine "corrects" our vertical position.  Horizontally, we just keep slowing our movement by reducing [api:Sprite.xd] until we come to a stop.

As you can see in the vertical movement section, we have special code to handle the case when we are on the ground and in the second phase.  If this is the case, we have to actually change our sprite size.  This is because when the character falls onto his back, he no longer fits into his 50x70 pixel box.  The final three death animation frames are actually 70x50.  So here we reset our [api:Sprite.width] and [api:Sprite.height] at the same time we switch images with [api:Sprite.setImage()].  We also have to change our [api:Sprite.hitRect] to something appropriate for our new shape.

Finally, when moving to the final phase, we use [api:Effect.Game.scheduleEvent()] to schedule a respawn of our character in a few seconds.  See [Respawning] below for what this function does.

=section #.#.#.#. Handling Hits

At various points in the code above, we move our sprite horizontally or vertically and take action based on the result (collision or no).  However, you may have noticed we also call "{handleHit()}" in each case.  This custom method handles running, falling, or otherwise moving into other sprites.  Here is the code:

=syntax js
	Character.add({
		handleHit: function(hit) {
			// perform action based on what we hit
			switch (hit.target.type) {
				case 'Crystal':
					// yay, a crystal!
					// the Crystal.grab() function takes care of destroying itself,
					// playing a sound effect, and leaving behind a 'Sparkle'
					hit.target.grab();
					this.crystals++;
					break;
					
				case 'Raven':
				case 'PotatoBug':
					// ouch, we hit an enemy!  that hurts.
					this.hurt( hit.target );
					break;
			}
		}
	} );

In this function we take a look at the type of object that was hit.  The "{hit}" object, which is returned from [api:Sprite.move()], has a "{target}" property which points to the actual object that was hit (sprite or tile).  So we can then look at the [api:Sprite.type] property (or [api:Tile.type] as the case may be), and take appropriate action.  These actions are moved off into their own function because we have multiple states which all need to handle these types of collisions.  This reduces duplicate code.

We only care about colliding with three types of sprites in this demo, so the function is rather simple.  If we hit a "{Crystal}" sprite, we call its custom "{grab()}" method (see below), and if we hit either of our enemy sprites, we call our own custom "{hurt()} method (also described below).

=section #.#.#.#. Taking Pain

When our player runs into an enemy (or an enemy runs into us), we have to take pain, and maybe die as well.  This is handled by a custom method called "{hurt()}".  Our character sprite actually calls this function itself, when he runs into enemies (see [Handling Hits] above), and enemies call it if |they| run into |him| (for example, if we are standing still, but an enemy walks or flies into us).  Here is the function:

=syntax js
	Character.add({
		hurt: function(source) {
			// something has hurt us!
			if (!this.invincibleTimer && this.energy) {
				// reduce our "energy" by one step
				this.energy--;
				if (this.energy <= 0) {
					// that's it, we're dead!
					this.state = 'dying';
					this.setImage( 'standing.png' );
					this.setFrameX( this.facingLeft ? 19 : 10 );
					this.deathPhase = 1;
					this.xd = this.facingLeft ? 16 : -16;
				}
				else {
					// okay, we're just hurt, not dead yet
					// make the character invincible and "blink" for a bit
					this.invincibleTimer = 120;
				}
			}
		}
	} );

The basic idea here is, we have a custom "{energy}" property that we set when the character is first spawned (and respawned).  Each time we are hurt, we decrement this value.  If it runs out, we are dead, and set our state to "{dying}" (explained above).

If we didn't die, we set a custom property called "{invincibleTimer}".  This does two things.  First, it makes us "invincible" for a few seconds, so we cannot get hurt (otherwise, we'd die immediately if we touched an enemy because each frame we would be hurt again).  Second, it activates a visual "blinking" effect, so the player knows we are invincible.  See [Draw Override] below for how this works. 

=section #.#.#.#. Respawning

When our character completely dies (either by falling off the bottom of the world, or losing all his energy and completing the "{dying}" state) we "respawn" the character at his starting position.  If you recall, back when we first loaded the level, we saved the character's starting position in two custom properties, "{respawnX}" and "{respawnY}":

=syntax js
	// save his current location for respawning
	player.respawnX = player.x;
	player.respawnY = player.y;

So armed with these, we simply have to reset the character's position, state and image, cleaning up any special properties, and the player can try the level again (he has infinite lives for this demo).  Here is our custom "{respawn()}" method:

=syntax js
	Character.add({
		respawn: function() {
			// respawn character after death
			this.width = 50;
			this.height = 70;
			this.hitRect.set( 10, 6, 40, 70 );
			this.x = this.respawnX;
			this.y = this.respawnY;
			this.facingLeft = false;
			this.state = 'falling';
			this.setImage( 'jumping.png' );
			this.setFrameX( this.facingLeft ? 14 : 1 );
			this.xd = 0;
			this.yd = 1;
			this.energy = 5;
			this.rocks = 99;
			this.invincibleTimer = 0;
			this.show();
		}
	} );

We have to reset our [api:Sprite.width], [api:Sprite.height] and [api:Sprite.hitRect], because the character might have gone through the death animation, and changed size (lying on his back).  We set our state to the default "{falling}" (which is probably immediately changed to "{standing}" if he respawns on solid ground), reset our deltas, give us a new supply of rocks and energy (our collected crystals carry over between lives), and reset the "{invincibleTimer}" if applicable.

=section #.#.#.#. Draw Override

Typically sprites do not have to override the built-in [api:Sprite.draw()] method, but we need to add a special visual "flickering" effect when our character is hurt.  What we are doing is "hiding" and "showing" the sprite every other draw frame, and this must be "synchronized" with the draw loop, or else we will miss frames and not see the flickering effect.  Here is our overridden method:

=syntax js
	Character.add({
		draw: function(clock) {
			// override built-in Sprite.draw() function to flicker character
			// if he just got hit by an enemy
			if (this.invincibleTimer) this.show( clock % 2 );
			
			// VERY IMPPORTANT: call parent draw() function to update our position
			this.__parent.draw.call(this);
		},
	} );

So here we are simply checking our custom "{invincibleTimer}" property, and if is non-zero (the player was just hit by an enemy and is invincible), we quickly switch our sprite's visibility on and off via [api:Sprite.show()} in sync with the draw clock (see [api:Effect.Game.drawClock]).

=section #.#.#. Rock Projectile

=image /effect/api/view/games/tutorial1/assets/images/sprites/character/rock.png class="checkers"

Our character can throw a rock projectile at enemies, which kills them.  The rock also bounces off solid surfaces, then falls offscreen and dies.  Here is the "{Rock}" class definition:

=syntax js
	Sprite.extend( 'Rock', {
		width: 16,
		height: 16,
		url: '/images/sprites/character/rock.png',
		collisions: true,
		dieOffscreen: true
	} );

Notice we are setting the [api:Sprite.collisions] property to {true}, which activates the engine collision system for this sprite, and the [api:Sprite.dieOffscreen] property to {true}, which will automatically destroy these objects when they leave the screen bounds.  That way we don't have to worry about them stacking up and slowing down engine performance.

Here is our [api:Sprite.logic()] routine:

=syntax js
	Rock.add({
		logic: function(clock) {
			// flying rock
			this.setFrameX( this.frameX + 1 );
			if (this.frameX > 31) this.setFrameX( 0 );
			
			// gravity is always pullin' us down
			if (this.yd < 8) this.yd += 0.4;
			
			// now move the sprite, horizontal only first
			var hit = this.move( this.xd, 0 );
			if (hit) {
				// if we hit something solid horizontally, bounce off, but slow down
				// and switch to non-collision mode (so it just falls offscreen)
				// hitting an enemy counts as 'solid'
				var hit_enemy = this.handleHit( hit );
				if (hit_enemy || hit.target.solid) {
					this.xd /= 4;
					this.xd = 0 - this.xd;
					this.collisions = false;
				} // hit solid
			} // hit something
			
			// now move vertically
			hit = this.move( 0, this.yd );
			if (hit) {
				// if we hit something solid vertically, bounce off, but slow down
				// and switch to non-collision mode (so it just falls offscreen)
				// hitting an enemy counts as 'solid'
				var hit_enemy = this.handleHit( hit );
				if (hit_enemy || hit.target.solid) {
					this.xd /= 2;
					this.yd /= 2;
					this.yd = 0 - this.yd;
					this.collisions = false;
				} // hit solid
			} // hit something
		}
	} );

When our characters first throws a rock (see [Throwing] above), our position and deltas are set for us.  So all we have to do is move in the direction we are headed, allow gravity to pull us down, and bounce off things (killing enemies if we hit them).

First, we control our animation, simply by incrementing our [api:Sprite.frameX] property, and looping around at the beginning once we run out of frames (the rock animation is seamless).

Next, we handle gravity and moving the sprite.  Once again we handle horizontal and vertical movement in two separate calls to [api:Sprite.move()], so we can know whether we hit something horizontally or vertically.  For example, if we hit something horizontally, we want to "flip" our horizontal delta, but preserve our vertical delta (this results in a more realistic physics simulation, albeit still very simplistic).

As you can see, when we hit something solid (or hit an enemy, which we consider to be "solid" for the purposes of animating the rock), we flip the affected delta ([api:Sprite.xd] or [api:Sprite.yd] as the case may be), but we also divide it by a constant.  This is because we're not throwing bouncy balls here, we're throwing rocks.  When a rock bounces, its speed decreases with every hit, as it comes to rest.

Also, notice that upon every hit, we set our [api:Sprite.collisions] flag to {false}.  This is because we're "cheating" physics a bit here, and only simulating one physical hit with the environment.  Once it bounces, the rock simply falls offscreen, even through solid ground, and will no longer hit anything else.

Finally, with every hit, horizontally or vertically, we call a custom "{handleHit()}" method (similar to the one the {Character} sprite has), which takes action based on the type of object that was hit.  Here is the code for that function:

=syntax js
	Rock.add({
		handleHit: function(hit) {
			// check if we hit an enemy, and if so, kill it
			switch (hit.target.type) {
				case 'Raven':
				case 'PotatoBug':
					// we hit a raven!  kill it!
					hit.target.hurt(this);
					return true; // treat this as solid
					break;
			}
			return false; // didn't hit anything interesting
		}
	} );

Here we are simply checking the "{type}" property of the object we hit, and checking if it is an enemy.  If so, we call the enemy's "{hurt()}" method (this handles killing the enemies, see below).  If you have lots of different kinds of enemies, you could simply set a custom property like "{category}", and set it to "{enemy}".  Then you can just check the category, instead of considering the actual sprite class names.  But for this demo we only have two enemies, so this works fine.

Finally, notice that this function returns either {true} or {false}, depending on if an enemy was hit, or not.  The return from this function is used in the "{logic()}" method above, and simply treats enemy hits as "solid", so the rock bounces off.  Enemies aren't typically marked as true "{solid}" (i.e. via [api:Sprite.solid]), because the character can't stand on them, but for the purposes of animating the rock, we act as tho they are.

=section #.#.#. Enemies

Here are the two enemy sprites we have in our demo.  One is explicitly placed in certain places in the level, and the other is randomly generated.

=section #.#.#.#. Potato Bug

=image /effect/api/view/games/tutorial1/assets/images/sprites/potato_bug.png class="checkers"

The "{PotatoBug}" enemy sprite simply walks around, bounces off walls, and hurts our character if they collide.  This enemy is placed into the level via the Level Editor, so these sprites are automatically created when scrolled into view.  Here is the class definition, and the first two methods:

=syntax js
	Sprite.extend( 'PotatoBug', {
		width: 54,
		height: 20,
		url: '/images/sprites/potato_bug.png',
		collisions: true,
		hitRect: new Rect(4, 4, 50, 20),
		facingLeft: false,
		state: 'walking',
		
		setup: function() {
			// this is called just as sprite is being created onscreen.
			// find player sprite, and set direction so we are facing toward him
			var player = this.plane.getSprite('player');
			this.facingLeft = (player.x < this.x);
			this.setFrameX( this.facingLeft ? 15 : 0 );
			this.xd = this.facingLeft ? -2 : 2;
			this.yd = 0;
		},
		
		logic: function(clock) {
			// call function named by our current state (i.e. walking, dying)
			this[ this.state ](clock);
		}
	} );

So in our class definition, we set our size, image, enable collisions, and set our [api:Sprite.hitRect].  The latter is because our sprite image has some "padding" around the bulk of the bug's body, so we only want to register collision if something |really| hits us.

As with the "{Character}" sprite, this sprite can switch directions, so we have a "{facingLeft}" property.  Also, we use a simple state machine to control our state (which is either "{walking}" or "{dying}") so we have a "{state}" property.

In the "{setup()}" method, which is called once at the moment the sprite is scrolled into view, we want to head in the character's direction.  So we locate the character sprite by its global ID using [api:SpritePlane.getSprite()].  Then we just compare our position, and set our direction accordingly.

In our "{logic()}" method, we simply call a method named by our current "{state}".  This is also how the main character sprite works.  Here is the default "{walking}" state handler:

=syntax js
	PotatoBug.add({
		walking: function(clock) {
			// walk around, bounce off walls, fall off ledges
			if (clock % 4 == 0) {
				if (this.facingLeft) {
					this.setFrameX( this.frameX - 1 );
					if (this.frameX < 8) this.setFrameX( 15 );
				}
				else {
					this.setFrameX( this.frameX + 1 );
					if (this.frameX > 7) this.setFrameX( 0 );
				}
			}
			
			// gravity is always pullin' us down
			if (this.yd < 8) this.yd += 0.5;
			
			// now move the sprite, horizontal only first
			var hit = this.move( this.xd, 0 );
			if (hit) {
				// if we hit something solid, switch direction
				if (hit.target.solid) {
					this.xd = 0 - this.xd;
					this.facingLeft = !this.facingLeft;
					this.setFrameX( this.facingLeft ? 15 : 0 );
				}
				this.handleHit( hit );
			}
			
			// now vertically (we're sorta combining walking and falling here)
			hit = this.move( 0, this.yd );
			if (hit) {
				// if we hit something solid, stop our vert movement
				if (hit.target.solid) {
					this.yd = 0;
				} // hit solid
				this.handleHit( hit );
			} // hit something
		}
	} );

This state actually handles both walking and falling.  The potato bug is technically always "falling", you just don't see it if he is positioned on solid ground.  Since we only have a single set of animation frames, with no transitions, we can get away with a single state for both.

First, we control our animation, which is just incrementing (or decrementing) our [api:Sprite.frameX] property, and looping it around.  This happens whether we are walking or falling.

Next, we apply the force of gravity by always incrementing our [api:Sprite.yd] property, and then handle moving the sprite, first horizontally, then vertically.  If we hit something horizontally, we "flip" our direction and head the other way.  If we hit something vertically, we simply set our [api:Sprite.yd] property to "{0}".  Also, as with many of our sprites, we call a custom "{handleHit()}" method, in case we hit a sprite we care about:

=syntax js
	PotatoBug.add({
		handleHit: function(hit) {
			// we hit something, see what it was...
			if (hit.target.type == 'Character') {
				// we hit the character, so inflict some pain!
				hit.target.hurt(this);
			}
		}
	} );

In this case the potato bug only cares about hitting the character.  If that happens, the potato bug wins, and the character gets hurt.

However, if a rock collides with us, we die.  So we provide a custom "{hurt()}" method, which puts our death in motion:

=syntax js
	PotatoBug.add({
		hurt: function(source) {
			// something hurt us.  go into "dying" mode, and screech
			// flip us upside down by setting the frameY to 1 (Mirror Vert Transform)
			this.setFrameY( 1 );
			this.state = 'dying';
			this.yd = -3;
			this.collisions = false;
			
			// inherit direction from the thing that hit us
			if (source.xd > 0 && this.xd < 0) this.xd = 0 - this.xd;
			else if (source.xd < 0 && this.xd > 0) this.xd = 0 - this.xd;
			
			// remove from aether database so corpse really dies when it leaves the screen
			this.removeFromAether();
			this.dieOffscreen = true;
		}
	} );

So here we are using a special image transform to flip us upside down.  When the "{PotatoBug}" sprite is first defined in the web interface, and we selected our PNG image, we also selected the "Mirror Horiz + Vert" transform.  This mirrors all the frames horizontally (so we can walk in either direction), and vertically, so we can flip upside down when we die and fall offscreen.  Here is how the transformed sprite image looks:

=image /effect/api/view/games/tutorial1/assets/images/sprites/potato_bug.png?filter=fliphv class="checkers"

So armed with this, we simply have to call [api:Sprite.setFrameY()] and pass in "{1}" (the index is zero-based), which activates the upside down frames.  We then set our state to "{dying}", and disable collisions.  We also "inherit" the horizontal direction from the rock that hit us, so if a rock hit us from the left, we'll head slightly to the right on our death fall.  We then set our state to "{dying}" to handle our final demise.

Finally, we call [api:Sprite.removeFromAether()] to remove the sprite from the database (so it isn't respawned).  These potato bugs are placed into the level via the Level Editor, so each one is individually stored and activated as the screen scrolls around the level.  But we want death to be permanent for these, so we remove the sprite from the database and set the [api:Sprite.dieOffscreen] flag, so when it falls, it really gets destroyed.

Here is the handler method for the "{dying} state:

=syntax js
	PotatoBug.add({
		dying: function(clock) {
			// we're dead, simply fall offscreen, no collision detection
			if (this.yd < 8) this.yd += 0.2;
			this.x += this.xd;
			this.y += this.yd;
		}
	} );

All we're doing here is increasing our [api:Sprite.yd], and manually moving our position based on our delta (no collision detection).  At this point we are dead, and have been "flipped over" and are upside down.  When we leave the screen, we automatically die.

=section #.#.#.#. Raven

=image /effect/api/view/games/tutorial1/assets/images/sprites/raven.png class="checkers"

The "{Raven}" enemy sprite is randomly spawned at the screen edges, and flies horizontally across the screen, injuring our player upon collision.  These sprites are not placed into the level via the Level Editor, so it must be specified as a "dependency" of the level (discussed above).

First, here is the code to randomly generate these raven sprites.  To do this we hook the [api:Effect.Game.onLogic] event, which fires once per iteration through the logic loop.

=syntax js
	Effect.Game.addEventListener( 'onLogic', function(clock) {
		// spawn ravens at random intervals and positions
		
		if (probably(0.005)) {
			// about one out of every hundred frames, at random
			var raven = Effect.Port.getPlane('sprites').createSprite( 'Raven', {
				y: Math.floor( Effect.Port.scrollY + (Effect.Port.portHeight * Math.random()) )
			} );
			
			if (probably(0.5)) {
				// half of the time spawn on the left, heading right
				raven.x = Effect.Port.scrollX - raven.width;
				raven.xd = 2;
				raven.facingLeft = false;
				raven.setFrameX( 5 );
			}
			else {
				// the other half of the time, spawn on the right
				raven.x = Effect.Port.scrollX + Effect.Port.portWidth;
				raven.xd = -2;
				raven.facingLeft = true;
				raven.setFrameX( 8 );
			}
		}
	} );

So here we are using the built-in static utility function [api:probably()], which is just a shorthand way to generate a random number between "{0.0}" and "{1.0}", and returns {true} if the result is |less| than a fixed value we pass to the function.  Remember this is called for every frame (45 times per second), so we want a 0.005 in 1 (i.e. 1 in 200) chance to spawn an enemy.  This turns out to be one every few seconds or so.

To spawn the enemy, we call [api:SpritePlane.createSprite()], and provide a random [api:Sprite.y] position, from the top of the screen to the bottom.  Remember that we need to specify global world coordinates, not screen coordinates, so we use the [api:Effect.Port.scrollY] and [api:Effect.Port.portHeight] properties to calculate our desired global position.  And then we choose randomly between the left and right sides of the screen, and set the bird's horizontal position and direction accordingly.

Here is the "{Raven}" class definition, and [api:Sprite.logic()] method:

=syntax js
	Sprite.extend( 'Raven', {
		width: 58,
		height: 60,
		url: '/images/sprites/raven.png',
		collisions: true,
		hitRect: new Rect(8, 8, 50, 52),
		dieOffscreen: true,
		facingLeft: false,
		state: 'flying',
		
		logic: function(clock) {
			// call function named by our current state (i.e. flying, dying)
			this[ this.state ](clock);
		}
	} );

So in our class definition, we set our size, image, enable collisions, and set our [api:Sprite.hitRect].  The latter is because our sprite image has some "padding" around the bulk of the bird's body, so we only want to register collision if something |really| hits us.

As with the "{Character}" sprite, this sprite can switch directions, so we have a "{facingLeft}" property.  Also, we use a simple state machine to control our state (which is either "{flying}" or "{dying}") so we have a "{state}" property.

In our "{logic()}" method, we simply call a method named by our current "{state}".  This is also how the main character sprite works.  Here is the default "{flying}" state handler:

=syntax js
	Raven.add({
		flying: function(clock) {
			// flap wings and move about the place
			if (clock % 8 == 0) {
				if (this.facingLeft) {
					this.setFrameX( this.frameX + 1 );
					if (this.frameX > 13) this.setFrameX( 8 );
				}
				else {
					this.setFrameX( this.frameX - 1 );
					if (this.frameX < 0) this.setFrameX( 5 );
				}
			}
			
			// move, but do NOT check tiles, so we can fly through ground
			// we only care about sprite vs. sprite collisions
			var hit = this.move( this.xd, this.yd, this.plane, null );
			if (hit) {
				if (hit.target.type == 'Character') {
					// we hit the character, so inflict some pain!
					hit.target.hurt(this);
				}
			}
		}
	} );

First, we simply "flap our wings" by animating our [api:Sprite.frameX] property, looping around at the beginning each time we hit the end.  We do this facing left or right, and the image is "mirrored", so the frame index is incremented or decremented accordingly.

Next, we handle movement and collision detection.  In this case we want the raven to be able to fly through solid ground, but still collide with sprites.  No problem, we use the optional arguments to [api:Sprite.move()] to specify that we do *not* want to consider the tile plane for collisions, and to only use the sprite plane.  Then we simply move, and check if we hit the character sprite (the only sprite we care about).  If so, we inflict pain (see [Taking Pain] above).

If the player throws a rock at us and it hits, the rock calls our "{hurt()}" method, which kills us.  Here is that method:

=syntax js
	Raven.add({
		hurt: function(source) {
			// something hurt us.  go into "dying" mode,
			// and throw out a bunch of feathers
			this.setFrameX( this.facingLeft ? 7 : 6 );
			this.state = 'dying';
			this.yd = 0;
			this.collisions = false;
			
			// inherit xd from the thing that hit us
			if (source.xd > 0 && this.xd < 0) this.xd = 0 - this.xd;
			else if (source.xd < 0 && this.xd > 0) this.xd = 0 - this.xd;
			
			for (var idx = 0; idx < 5; idx++) {
				this.plane.createSprite( 'Feather', {
					x: this.x + Math.floor( Math.random() * 42 ),
					y: this.y + Math.floor( Math.random() * 44 )
				} );
			}
		}
	} );

So when we die, we switch states to "{dying}", switch our animation frame to a special "dead" image, and disable collisions (we can only die once).  Then we "inherit" the horizontal direction from the rock that hit us, so if we got hit from the left side, we'll fall diagonally to the right.  Finally, we create 5 "{Feather}" sprites, which float down off the screen.  Those are discussed below.

Here is the "{dying}" state handler, which is very simple:

=syntax js
	Raven.add({
		dying: function(clock) {
			// we're dead, simply fall offscreen, no collision detection
			if (this.yd < 8) this.yd += 0.2;
			this.x += this.xd;
			this.y += this.yd;
		}
	} );

Here we are simply increasing our vertical delta due to gravity, and moving our position by our deltas (no collision detection).  As soon as our dead corpse leaves the screen bounds, the sprite is automatically destroyed.

=section #.#.#. Raven Feather

=image /effect/images/docs/tutorials/platformer/feather-rotate.png class="checkers"

The "{Feather}" sprite is thrown out multiple times by the "{Raven}" when he dies.  These simply float down offscreen, and are automatically destroyed when they leave the screen bounds.  Here is the class definition and "{logic()}" method:

=syntax js
	Sprite.extend( 'Feather', {
		width: 26,
		height: 26,
		url: '/images/sprites/feather-24.png',
		dieOffscreen: true,
		
		setup: function() {
			// setup random floating movement
			this.xd = (Math.random() * 0.5) - 0.25; 
			this.angle = Math.floor( Math.random() * 360 );
			this.angleDir = probably(0.5) ? 1 : -1;
			this.yd_target = Math.floor( Math.random() * 5 );
			this.mode = 1;
		},
		
		logic: function(clock) {
			// animate, then destroy self
			if (this.mode == 1) {
				// increasing speed and rotation
				this.yd += 0.2; 
				if (this.yd >= this.yd_target) this.mode = 2;
			}
			else {
				this.yd -= 0.2; 
				if (this.yd <= 0) {
					this.angleDir = probably(0.5) ? 1 : -1;
					this.yd_target = Math.floor( Math.random() * 5 );
					this.mode = 1;
				}
			}

			this.x += this.xd;
			this.y += this.yd;
			this.angle += (this.yd * 3 * this.angleDir);
			this.setRotation( this.angle );
		}
	} );

These sprites have no collision detection, and simply animate while falling offscreen.  However, one interesting engine feature is demonstrated here.  We only have a single frame of the feather, which is rotated in the engine using the "Rotation" image transform.  Then, we simply have to call [api:Sprite.setRotation()] to set the angle, and the engine picks the correct frame to match our desired angle.

In the [api:Sprite.setup()] method, we are setting a random direction, delta, angle, and a custom "{mode}" property.  The mode is just an animation control mechanism, so we can behave somewhat like a feature, and speed up and slow down our descent, fluctuating between the two states.

In the [api:Sprite.logic()] method, we simply animate our frame and position, while slowly falling downward until we leave the screen.  Since our [api:Sprite.dieOffscreen] property is set, the engine will automatically destroy the sprite when we leave the screen bounds.

=section #.#.#. Crystals

=image /effect/api/view/games/tutorial1/assets/images/sprites/crystal_med.png class="checkers"

Scattered throughout the level are some "crystals" for our character to collect.  These are placed via the Level Editor, and their positions are fixed (they don't move).  So the code to handle the crystal is very simple:

=syntax js
	Sprite.extend( 'Crystal', {
		width: 24,
		height: 48,
		url: '/images/sprites/crystal_med.png',
		collisions: true,
		
		logic: function(clock) {
			// spin the crystal
			if (clock % 3 == 0) {
				this.setFrameX( this.frameX + 1 );
				if (this.frameX > 31) this.setFrameX( 0 );
			}
		},
		
		grab: function() {
			// the player calls this when he grabs us
			// destroy self, and leave behind a sparkle object
			this.plane.createSprite( 'Sparkle', {
				x: (this.x + 12) - 32,
				y: (this.y + 24) - 32
			} );
			this.destroy();
		}
	} );

In our [api:Sprite.logic()] method we simply animate our frame by calling [api:Sprite.setFrameX()], looping around at the beginning when we reach the end.  Nothing else needs to be done there.

However, we have to handle the case when the player collides with the crystal.  You may recall back in the "{Character}" sprite class, we wrote a custom "{handleHit()}" method, which takes certain action based on the type of sprite that was hit.  And if the player collided with a crystal, he calls our "{grab()}" method.  This method destroys the crystal sprite, and throws out a [Sparkle] for a visual effect.

=section #.#.#.#. Sparkle

=image /effect/api/view/games/tutorial1/assets/images/sprites/sparkle.png class="grey"

The "{Sparkle}" sprite is leftover when a "{Crystal}" is collected by the player.  Since this sprite isn't placed into the level via the Level Editor, it is listed as a dependency for the "{Crystal}" sprite, so it is loaded when needed.  All this sprite does is animate its frames, then kills itself.  The code:

=syntax js
	Sprite.extend( 'Sparkle', {
		width: 64,
		height: 64,
		url: '/images/sprites/sparkle.png',
		dieOffscreen: true,
		
		logic: function(clock) {
			// animate, then destroy self
			if (clock % 5 == 0) {
				this.setFrameX( this.frameX + 1 );
				if (this.frameX > 7) this.destroy();
			}
		}
	} );

So all we are doing here is advancing the animation frame via [api:Sprite.setFrameX()], and when it hits the end of the frames, it calls [api:Sprite.destroy()].

=section #.#.#. Checkpoints

=image /effect/api/view/games/tutorial1/assets/images/sprites/rod.png class="checkers"

A nice thing you can do for your players is offer "checkpoints" throughout difficult levels.  So when they die, you can respawn them at the last checkpoint, so they don't have to play the entire level over again.  In this case we have a simple checkpoint object (pictured above) that we'll place in certain locations via the Level Editor.  When the player collides with the object, we'll "save" his position for respawning.

You may recall back when we first loaded the level, we set two custom properties on the {Character} sprite, "{respawnX}" and "{respawnY}":

=syntax js
	player.respawnX = player.x;
	player.respawnY = player.y;

These stored the character's starting position, which we use to "respawn" him after dying.  So all the checkpoint has to do is update these properties.  Here is the "{Checkpoint}" class definition and all methods:

=syntax js
	Sprite.extend( 'Checkpoint', {
		width: 30,
		height: 70,
		url: '/images/sprites/rod.png',
		collisions: true,
		activated: false,
		
		setup: function() {
			// set animation frame based on our activation state
			this.setFrameX( this.activated ? 1 : 0 );
		},
		
		save: function(player) {
			// the player calls this when he hits us
			// activate checkpoint, glow, save position, and play a sound
			if (!this.activated) {
				this.activated = true;
				this.setFrameX( 1 );

				player.respawnX = this.x;
				player.respawnY = this.y;
			}
		}
	} );

The thing to notice here is the custom "{activated}" property.  This will start out as {false}, but we set it to {true} as soon as the Character collides with the object, in our custom "{save()}" method.  Also, we update our animation frame to show a visual cue that the checkpoint has been activated, and then update the player's special "{respawnX}" and "{respawnY}" properties to the position of the checkpoint sprite itself.

The {Character} sprite class must be made aware of this object, so our "{save()}" method is called properly upon collision.  All we have to do is add this little snippet of code to the character's "{handleHit()}" method, where we take different actions based on the type of object that was hit:

=syntax js
	case 'Checkpoint':
		// yay, a checkpoint!
		hit.target.save(this);
		break;

One last thing to discuss about the checkpoint is the ability to "remember" its state if it moves offscreen.  We want the checkpoint to remember that it has been activated (or not), and restore that state if the player leaves the area, and returns later.  Since this sprite is placed into the Level Editor, it is managed by a special sprite database that automatically "freezes" and "defrosts" sprites as they leave and enter the screen.  This database only remembers certain information about the sprite, namely its ID, position, and any custom properties defined in the web interface.  But we want our special "{activated}" property to be remembered as well.  So all we have to do is define a property called "{activated}", so the engine knows to freeze and defrost this with the other sprite information.  This is done by editing the Sprite Class in the web interface and clicking the "Add Property..." button:

=image /effect/images/docs/tutorials/platformer/checkpoint_props.png

It doesn't really matter which control type we select (menu, text field or checkbox), but we've chosen "Checkbox" here because it is a simple {true} or {false} value, which best represents our use of the "{activated}" property in our code.  If we chose a menu or text field, we'd get a "string" type for the property, which just means we'd have to do a litle more code wrangling to evaluate the property value.

Alternatively, you could just use the [api:Sprite.addAetherProp()] method to dynamically add the "{activated}" property to the database for our sprite.  You should call this in your "{setup()}" method.

=section #. Adding Sound Effects and Music

Up until now, our platformer demo has been silent.  But here is how we can easily add both sound effects and background music to the game.  First, we need some assets.  Once these are uploaded, we can go to the "Audio" tab and configure a few settings:

=image /effect/images/docs/tutorials/platformer/audio.png

First, we set the audio track categories based on the type of sound.  For example, all our sound effects are in the "SFX" category, and our background music track is in the "Music" category.  This does two things.  First, we can control the overall volume of each category if we want, and this allows the engine to control the music separately, if the user chooses to disable it in the toolbar.

Finally, we set some options like enabling looping on our music track, enabling multiplex on our sound effects (see the [article:docs/Audio Guide]), and adjusting a few individual track volumes where necessary.

=section #.#. Music

To handle playing background music, we first need to have the level specify which music track to play.  While we could just hard-code this, we want to show how you could do it with multiple levels and multiple music tracks.  So if you recall, back in the [Level Properties] section above, we set a custom "{music}" property for all levels, and then specifed our music filename in our level.  So all we have to do is grab the level properties, and tell the music track to play.

Here is the setup code, which should be executed just after your level finishes loading:

=syntax js
	// start our music track
	var music_id = Effect.Game.getLevelProps().music;
	if (music_id) Effect.Audio.getTrack( music_id ).play();

Couldn't be easier, right?  We just grab the filename from the level properties via [api:Effect.Game.getLevelProps()], grab the audio track via [api:Effect.Audio.getTrack()], and tell it to play via [api:Effect.AudioTrack.play()].  See the [article:docs/Audio Guide] for details on these calls.

But wait, there are a few more situations we have to handle here.  First, if the user pauses or resumes the game, it is our responsibility to stop and start our music track.  And finally, if the user disables, then re-enables music from the toolbar, we also have to resume our track.  Don't worry, this is all very easy, with just a few lines of code.  Observe:

=syntax js
	// Hook the pause and resume events so we can control the music
	Effect.Game.addEventListener( 'onPause', function() {
		Effect.Audio.quiet();
		Effect.Audio.playSound( 'pause.mp3' );
	} );
	
	Effect.Game.addEventListener( 'onResume', function() {
		Effect.Audio.playSound( 'pause.mp3' );
		
		// fade music back in over 45 frames, to not overwhelm the sound effect
		var music_id = Effect.Game.getLevelProps().music;
		if (music_id) Effect.Audio.getTrack( music_id ).fadeIn( 45 );
	} );
	
	// finally, if the user has disabled, then re-enabled music, we have to resume the track
	Effect.Game.addEventListener( 'onEnableMusic', function() {
		var music_id = Effect.Game.getLevelProps().music;
		if (music_id) Effect.Audio.getTrack( music_id ).play();
	} );

So, three different event hooks here:

=list
	First, we are hooking the [api:Effect.Game.onPause] event, and silencing all sound (including our music track).  Then we are playing a short "pause" sound effect (see below).
	Second, we are hooking the [api:Effect.Game.onResume] event, and re-starting our music track, and playing the pause sound again.  But this time, we use [api:Effect.AudioTrack.fadeIn()] to fade the music back in over a second (so it doesn't overwhelm the sound effect).
	And finally, we are hooking the [api:Effect.Game.onEnableMusic] event, which is fired if the user disables, then re-enables music by the toolbar.  In this case, we just restart our music track (no fade needed here).

That about does it for music.  Now, onto the sound effects!

=section #.#. Sound Effects

Our demo has 24 different sound effects, nearly all of which are handled by sprites.  For the one effect that isn't, let's explain it first.  We have a custom "pause" sound that we play when the engine is paused or resumed.  This effect is therefore marked for "preload" (so it automatically loads at startup), and played in our [api:Effect.Game.onPause] and [api:Effect.Game.onResume] event handlers (see above).

The rest of our sound effects are handled by our sprites.

=section #.#.#. Character Sound Effects

18 of the sound effects are all handled by our character sprite.  These range from footsteps, to hitting our head, to throwing rocks, to getting injured, to dying.  These are all listed as "resources" in the sprite definition, so they are automatically loaded when the sprite does.

In all cases playing these effects are simple calls to [api:Effect.Audio.playSound()], but we sometimes pick from a random set of effects for some variety.  For example, when our player gets hurt, we pick from one of two pain sound effects ("{pain1.mp3}" and "{pain2.mp3}").  And a very similar thing takes place when he dies (we have two "death" sounds).  So let's take a look at an upgraded "{hurt()}" method from our "{Character}" sprite:

=syntax js
	Character.add({
		hurt: function(source) {
			// something has hurt us!
			if (!this.invincibleTimer && this.energy) {
				// reduce our "energy" by one step
				this.energy--;
				if (this.energy <= 0) {
					// that's it, we're dead!
					this.state = 'dying';
					this.setImage( 'standing.png' );
					this.setFrameX( this.facingLeft ? 19 : 10 );
					this.deathPhase = 1;
					this.xd = this.facingLeft ? 16 : -16;
					
					// pick one of our 2 "death" sounds to play
					var sound_num = 1 + Math.floor( Math.random() * 2 );
					Effect.Audio.playSound( 'death' + sound_num + '.mp3' );
				}
				else {
					// okay, we're just hurt, not dead yet
					// make the character invincible and "blink" for a bit
					this.invincibleTimer = 120;
					
					// pick one of our 2 "pain" sounds to play
					var sound_num = 1 + Math.floor( Math.random() * 2 );
					Effect.Audio.playSound( 'pain' + sound_num + '.mp3' );
				}
			}
		}
	} );

Notice that we are now playing a sound when we get hurt, and when we die.  We also construct our filename based on a random number, for a little variety.  This same technique is also used when the character throws a rock.  We pick from a set of 3 "whoosh" noises, and play it in our "{throw_rock()}" method:

=syntax js
	// pick one of our 4 throwing "swish" sounds and play it
	// throw1.mp3, throw2.mp3, throw3.mp3 or throw4.mp3
	var sound_num = 1 + Math.floor( Math.random() * 4 );
	Effect.Audio.playSound( 'throw' + sound_num + '.mp3' );

You may have noticed that you can hear "footstep" sound effects as the character runs around the level.  You may also have noticed that these change based on what he is standing on.  To accomplish this, we have two sets of sound effects, one for "ground" and another for "stone", and four effects in each group.  To choose which set of effects to play, we have to look at what we are standing on.

Back in the [Tiles] section above, we created two different tile classes, one for "{Ground}" and another for "{Stone}".  These are applied to the appropriate tiles in the level via the Level Editor.  So, if we look at what object we hit |below| us while running, we can check the object's [api:Tile.type] property, and choose the right set of sound effects for the type of ground.  First, let's write a "{footstep()}" method to call:

=syntax js
	Character.add({
		footstep: function(hit) {
			// play footstep sound based on what we're standing on
			// our sound filenames are 'run-ground-step1.mp3', 'run-ground-step2.mp3', etc.
			// and 'run-stone-step1.mp3', 'run-stone-step2.mp3', and so on, thru 4.
			// Our solid tiles have class names of "Ground" and "Stone", so we just have to
			// put together a string with the class name, with a random number between 1 and 4.
			var stepnum = 1 + Math.floor( Math.random() * 4 );
			var filename = 'run-' + hit.target.type.toLowerCase() + '-step' + stepnum + '.mp3';
			Effect.Audio.playSound( filename );
		}
	} );

So as you can see, this method expects a "{hit}" object to be passed in.  The [api:Sprite.move()] method returns this object when we perform movement and collision detection, so all we have to do is augment our "{running()}" method to know when our animation has a foot hitting the ground, and call the "{footstep()}" method, passing in the hit object of what lies |under| us.  Here is the code added to the end of the "{running()} method:

=syntax js
	// play footstep sound effect for certain animation frames
	// but only if we just switched frames (avoid repeats)
	if (clock % frameMod == 0) {
		switch (this.frameX) {
			case 2:
			case 6:
			case 7:
			case 11:
				this.footstep(hit);
				break;
		}
	}

As you may recall, the character's "{running()}" method sets a "{frameMod}" variable based on how fast we are running.  If the logic clock modulus the frame mod is zero, then the animation frame |just| changed.  This is the time we want to check the frame, and play a footstep sound if appropriate.  In the case of our running animation, there are two frames in each direction where this is appropriate (the left and right foot).  For these frames only we call our "{footstep()}" method.

There are also some other cases where "{footstep()}" is called.  For example, when you are falling and hit solid ground, this triggers a footstep sound effect.  Also, if you start running then immediately stop, it "appears" that you took a step, so we play another footstep in that case.

Finally, when the player is jumping upward and hits something solid above him, we play a "thump" sound effect.  This is done by adding a little code to the vertical movement code in the "{falling()}" method:

=syntax js
	// now move vertically
	hit = this.move( 0, this.yd );
	if (hit) {
		// if we hit something solid, stop our vert movement
		if (hit.target.solid) {
			if (this.yd > 0) {
				// player was falling downward, so we hit solid ground
				if (Math.abs(this.xd) > 1) {
					// player is in motion, go straight to running
					this.state = 'running';
					this.setImage( 'running.png' );
					this.setFrameX( this.facingLeft ? 13 : 0 );
				}
				else {
					// player is idle, go to standing
					this.state = 'standing';
					this.setImage( 'standing.png' );
					this.setFrameX( this.facingLeft ? 29 : 0 );
				}
				this.hitRect.top = 6;
				if (this.yd > 1) this.footstep(hit);
			}
			else {
				// player was jumping upward, so we hit our head
				Effect.Audio.playSound( 'hit_head.mp3' );
			}
			this.yd = 0;
		} // hit solid
		this.handleHit( hit );
	} // hit something

So as you can see here, when moving vertically and hit something solid, we take action based on our direction.  If headed downward, we switch state to "{running}" or "{standing}", and play a footstep sound effect.  But if headed |upward|, we play our "{hit_head.mp3}" effect.

=section #.#.#. Misc Sound Effects

Compared to the sound effect code in the character sprite, the other sprite sound effects are easy.  Let's take a look:

When the {Raven} sprite dies, we play a loud "caw" sound effect.  This file is listed as a resource for the sprite, so it is automatically loaded as needed.  We only have one of these effects, so we just add this to the end of the raven's "{hurt()}" method:

=syntax js
	Effect.Audio.playSound( 'caw.mp3' );

When the {PotatoBug} sprite dies, we play a "screech" sound effect.  We have two of these, so we go random again.  This code is added to the end of the bug's "{hurt()}" method:

=syntax js
	// pick one of our 2 "screech" sounds to play
	var sound_num = 1 + Math.floor( Math.random() * 2 );
	Effect.Audio.playSound( 'screech' + sound_num + '.mp3' );

When the {Rock} sprite hits anything solid, we play a small "thump" noise.  This line of code is added to the rock's "{logic()}" method:

=syntax js
	Effect.Audio.playSound( 'rock_hit.mp3' );

When the {Checkpoint} sprite is activated, we play a little chime:

=syntax js
	Effect.Audio.playSound( 'checkpoint.mp3' );

Finally, when the {Crystal} sprite is collected by the player, we play a little jingle sound effect.  This line of code is added to the crystal's "{grab()}" method:

=syntax js
	Effect.Audio.playSound( 'crystal.mp3' );

That's it for all our audio code!

=section #. Adding a Heads-Up Display

Up until now, we haven't discussed the "heads-up display" (the overlay showing our crystal count, rock count, and health), besides showing our custom font image.  Let's take a closer look at this:

=image /effect/images/docs/tutorials/platformer/font.png class="grey"

The standard Bitmap Font creator was used to create this image, but we downloaded the font image to customize it. For example, we added a drop shadow, and replaced a few of the unused glyphs with "icons" for the heads-up display.  See the [article:docs/Font Guide] for details on Bitmap Font and customizing the image.

The exclamation point glyph ({!}) was replaced with a "crystal" icon, the quotation marks glyph ({"}) was replaced with a "rock" icon, and the hash mark glyph ({#}) was replaced with a "heart" icon, representing our player's health.

To implement this in code, we just need a few additions.  First, we have to create a [api:HUD] layer, and attach it to our main display port.  This is done after the level is loaded:

=syntax js
	// initialize our heads-up display
	var hud = new HUD('hud');
	hud.setZIndex( 5 );
	hud.setCustomFont( '/fonts/gun4fc-20pt.png', 20, 24 );
	hud.setTableSize( 30, 1 );
	hud.setTracking( 0.9, 1.0 );
	hud.setPosition( 10, 6 );
	hud.setChar( 0, 0, '!' ); // special glyph for "crystals" icon
	hud.setChar( 4, 0, '"' ); // special glyph for "rocks" icon
	Effect.Port.attach(hud);

So here we create our layer, and give it an ID of "{hud}" (so we can easily get access to it later), and set the z-index to 5 (which is above all our other layers).

Next we set the custom font image via a call to [api:HUD.setCustomFont()], and specify our glyph size (20x24 pixels).  Our font image was preloaded by listing it as a game resource.  Remember, images all have to be loaded in order to be used.

Then we set our desired columns and rows via a call to [api:HUD.setTableSize()].  In this case our heads-up display is only a single row (one line of text), but we want it 30 columns wide (30 glyphs across), because we display our character's crystals and rocks on the left, and his health on the right.

Next we set the glyph tracking via a call to [api:HUD.setTracking()].  By setting the horizontal tracking to "{0.9}", the glyphs will |slightly| overlap each other, creating a better visual look for the font.  Remember these are "monospace" fonts, so a little tracking adjustment is nice.

After that, we set our origin position to 10x6, just to give us a little margin around the screen borders.

Then, we write a few characters to the HUD that never change.  In this case, our "crystal" and "rock" icons, which are displayed next to the crystal and rock counts, are fixed and never move.  So those can go in now, via calls to [api:HUD.setChar()].  Instead of creating custom sprites for these icons, we simply "replaced" some glyphs in our font map with the crystal and rock images.  So we just write out the characters that used to live in those glyph map positions (an exclamation point and quotation mark in this case).

Finally, we attach the HUD ot the main display port.  This initializes the layer and activates it in the engine.

So now, we have to "update" the HUD display when things change with our character.  For example, when he collects a crystal, throws a rock, or gets hurt, we have to update the HUD display so it stays current.  For this, let's write a single "{update_hud()}" method in our {Character} class:

=syntax js
	Character.add({
		update_hud: function() {
			// update heads-up display with our crystals, rocks, and life meter
			var hud = Effect.Port.getPlane('hud');
			hud.setPadInt( 1, 0, this.crystals, 2 );
			hud.setPadInt( 5, 0, this.rocks, 2 );
			
			// construct string containing spaces and '#' characters (heart glyphs in our font)
			var str = '';
			for (var idx = 0; idx < this.energy; idx++) str += '#';
			while (str.length < 5) str = ' ' + str;
			hud.setString( 22, 0, str );
		}
	} );

So here we grab a reference to our HUD, via a call to [api:Effect.Port.getPlane()].  Then we update our crystal and rock counts via calls to [api:HUD.setPadInt()].  This method displays the counts as numbers padded with zeros, so they always take up the same space.

For our "health" display, we show a number of "heart" icons.  These icons take the place of the hash mark ("{#}") glyph, so we generate a string containing the number of hash marks for our health count (0 thru 5), padded with spaces on the left (so the heart display is right-aligned).  Then we just write out the string to the HUD via a call to [api:HUD.setString()].

Our character then has to call "{update_hud()}" at various places.  For example, in his "{setup()}" method, so the HUD is updated when the level first loads.  Also, when crystals are collected (in the "{handleHit()}" method), when we throw a rock (in the "{throw_rock()}" method), and when we are injured (in the "{hurt()}" method).

=section #. Adding a Title Screen

=image /effect/images/docs/tutorials/platformer/title.jpg

Up until now, our demo has immediately loaded our level and started the game.  Now let's see what it would take to add a "title screen" which loads first, and has a "New Game" button which loads the level and begins the actual game.

There are several ways to do this, but often the easiest way to implement a title screen is to make it a "level".  Meaning, design your interface elements as sprites, perhaps a big background image, create a level called "{TitleScreen}", mark it for preload, load it in code, and you're good to go.

In our case we have one large image that holds everything in the screenshot above (background, logo, main title, tree), except for the "New Game" button.  That will be a sprite with its own image, because it needs to receive mouse clicks:

=image /effect/api/view/games/tutorial1/assets/images/title_screen/button.png style="border:0"

First, we create a sprite class named "{NewGameButton}", which loads the button image above, plus a sound effect for clicking the button.  Now we simply create a level called "{TitleScreen}", set the size to one screen (512x320 pixels, no scrolling), set the background image, create one single sprite layer to hold our button, and stick it into the level.

In our game code, instead of loading our level at startup, we load the title screen instead:

=syntax js
	// load title screen
	Effect.Game.loadLevel( 'TitleScreen', function() {
		// title screen is now loaded
		// hook mouse events for the "New Game" button
		var button = Effect.Port.getPlane('sprites').getSprite('newgame');
		button.captureMouse();
		
		// play intro jingle
		Effect.Audio.playSound( 'intro.mp3' );
	} );

A couple things to note here.  First, we are immediately locating our "New Game" button and calling [api:Sprite.captureMouse()] on it (for this to work, the sprite class must be marked as "Always Active" in the web interface).  Then, we play a little intro musical jingle.  The title screen level has this MP3 listed as a resource, so it is preloaded for us.

Now let's take a look at the "{NewGameButton}" sprite code:

=syntax js
	Sprite.extend( 'NewGameButton', {
		width: 130,
		height: 24,
		url: '/images/title_screen/button.png',
		collisions: false,
		
		onMouseDown: function() {
			// player has clicked us, let's start the game!
			start_new_game();
		}
	} );

So you'll notice that this sprite has no "{logic()}" method.  All it has is an "{onMouseDown()}", which is called when the player clicks the mouse on the button (this only works if you first call [api:Sprite.captureMouse()], which we did when the title screen loaded).

So when clicked, the function calls "{start_new_game()}", which is a brand new function.  This is where our level loading code has moved to.  Here is how it looks now:

=syntax js
	function start_new_game() {
		// start new game (called from title screen)
		Effect.Audio.playSound( 'crystal.mp3' );
		Effect.Port.removeAll();
		Effect.Port.setBackgroundColor('black');
		
		Effect.Game.loadLevel( 'Level1', function() {
			// level is loaded!
			
			// initialize our heads-up display
			var hud = new HUD('hud');
			hud.setZIndex( 5 ); // above everything else
			hud.setCustomFont( '/fonts/gun4fc-20pt.png', 20, 24 );
			hud.setTableSize( 30, 1 );
			hud.setTracking( 0.9, 1.0 );
			hud.setPosition( 10, 6 );
			hud.setChar( 0, 0, '!' ); // special glyph for "crystals" icon
			hud.setChar( 4, 0, '"' ); // special glyph for "rocks" icon
			Effect.Port.attach(hud);
			
			// get references to our planes, which were created when the level loaded
			var splane = Effect.Port.getPlane('sprites');
			var tplane = Effect.Port.getPlane('tiles');
			
			// connect the planes, for collision detection
			splane.linkTilePlane( tplane );
			
			// locate our player sprite and scroll to his position
			var player = splane.getSprite( 'player' );
			Effect.Port.follow( player );
			
			// save his current location for respawning
			player.respawnX = player.x;
			player.respawnY = player.y;
			
			// update our HUD with the player's current stats
			player.update_hud();
			
			// start our music track
			var music_id = Effect.Game.getLevelProps().music;
			Effect.Audio.getTrack( music_id ).play();
			
			// hook the onLogic event to spawn enemies
			Effect.Game.addEventListener( 'onLogic', function(clock) {
				// spawn ravens at random intervals and positions
				if (probably(0.005)) {
					// about one out of every hundred frames, at random
					var raven = Effect.Port.getPlane('sprites').createSprite( 'Raven', {
						y: Math.floor( Effect.Port.scrollY + (Effect.Port.portHeight * Math.random()) )
					} );
					
					if (probably(0.5)) {
						// half of the time spawn on the left, heading right
						raven.x = Effect.Port.scrollX - raven.width;
						raven.xd = 2;
						raven.facingLeft = false;
						raven.setFrameX( 5 );
					}
					else {
						// the other half of the time, spawn on the right
						raven.x = Effect.Port.scrollX + Effect.Port.portWidth;
						raven.xd = -2;
						raven.facingLeft = true;
						raven.setFrameX( 8 );
					}
				}
			} );
		} );
	}

Much of this code is repeated from before.  We've just moved it into this function, so it only activates when the user clicks the "New Game" button.

One thing to note is this little bit of code:

=syntax js
	Effect.Port.removeAll();
	Effect.Port.setBackgroundColor('black');

This "clears" the entire screen before loading the level.  By default, the engine does not "remove" any of your sprites, tiles or planes when switching levels.  That is because you may want to keep some sprites around (like, your player sprite).  So if you want to remove everything, call [api:Effect.Port.removeAll()] to remove all the planes, and then [api:Effect.Port.setBackgroundColor()] to clear the background image with a solid color (in this case black).  This just looks better when loading.

That's it!

=section #. Summary

We certainly hope you enjoyed this little platformer tutorial.  This by no means demonstrates everything the engine can do, it just shows some possible techniques for use in a 2D sidescrolling platform game.  Feel free to download the source code for use in your own games:

[button:compress.png /effect/images/docs/tutorials/platformer/effect-platform-tutorial-source.zip Download Source Code]

=section #.#. Further Reading

Several topics in this tutorial are covered in depth in the following documents:

=list
	[article:docs/Sprites and Tiles Guide]
	[article:docs/Geometry and Collision Guide]
	[article:docs/Audio Guide]
	[article:docs/Font Guide]
	[article:docs/Level Editor Guide]
