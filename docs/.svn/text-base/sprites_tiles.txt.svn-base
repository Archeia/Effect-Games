=article_title Sprites and Tiles Guide
=article_path /docs
=article_tags docs, sprites, tiles
=article_stags sidebar_docs
=article_comments 1
=section_numbers 1
=toc 1
=toc_max 3

=section #. Overview

Sprites and Tiles are the building blocks of your game.  This document describes how to use Sprites and Tiles in the Effect Engine, from how to define them in the web interface, add properties to customize them, place them into levels, and finally how to write code to control them.

You must attach sprites and tiles to "planes".  A plane is a layer of graphics in your game, and can hold sprites, tiles, text or even video.  You can have as many planes as you want, and control which planes are in front of others by setting their [wikipedia:Z_order, z-index] values.  Consider the following game screenshot:

=image /effect/images/docs/sprites_tiles/game_screenshot.png
=caption Screenshot of sidescroller game.

This game has three visual layers: a background layer on the bottom which has the image of the sky and clouds, a tile plane in the middle which has the level graphics, and a sprite plane on top which has all the moveable objects, like the character, enemies and items.  Here you can see the three layers split apart:

=image /effect/images/docs/sprites_tiles/game_layers.png style="border:0"

So the background layer would have a z-index of "0", the tile plane a z-index of "1", and the sprite plane a z-index of "2".  Lower numbers are behind, and higher numbers are in front.  You can actually assign separate z-indexes to individual sprites in a plane -- they can each appear above, or below any other plane.

Each plane can have its own "scroll speed", so you set some planes to scroll slower or faster than others (this includes the background layer).  In this way you can achieve [wikipedia:Parallax scrolling] for your games.

=section #. Sprites

A Sprite is any movable object, which could be the player, an enemy, a bullet, a power-up, a clickable button, basically anything that can move independently, and can also have animation and behaviors attached.  Sprites may have any number of animation frames, which you an easily control in code.

Each Sprite is controlled by a class which you define in the web interface, then write code for in your game.  You can of course create multiple sprites of the same class, have sub-classes which inherit from parent sprites, and define properties to customize individual sprites beyond their class defaults.

=section #.#. Defining Sprite Classes

To define a sprite class, navigate to the "Objects" tab and click "Add Sprite Class".

=image /effect/images/docs/sprites_tiles/objects_sprites.png
=caption List of sprite classes.

Then, fill out the form for creating a new sprite class.  Here are descriptions of all the form fields:

=section #.#.#. Sprite Class Name

For your sprite class name, enter the exact same string as you would in your code to identify the class.  This is case-sensitive.  If your sprite class is nested in one or more namespaces, make sure to specify them all in the class name here, separated by periods.  Some example class names:

=syntax text
	Player
	Enemy1
	MyGame.Sprites.MySprite1

=section #.#.#. Preload Sprite

You can choose to "preload" all of your sprite's resources by checking this checkbox.  Sprites can define resources they need such as images, audio tracks, and XML files, which can be loaded at startup, or on demand (i.e. when a level is loaded that has one or more instances of the sprite placed in the world).  For more, see [Sprite Resources] below.

=section #.#.#. Place Sprite in Level Editor

You may wish to place certain sprites into levels in the level editor.  For example, enemies and power-ups that have preset placement in levels (i.e. not generated by code).  Sprites marked for placement are listed in the level editor's "Sprites" palette.  If you check this box, more options appear (see next sections).

Note that you may choose not to use the level editor at all, and generate your game's content procedurally, or implement your own custom level editor.  In either case, simply do not check this box.  For details on the level editor, see the [article:docs/Level Editor Guide].

=section #.#.#.#. Sprite Size

Typically your sprite size is defined in your code, but since you chose to place it into levels, you must specify a size for the level editor.  Enter the sprite width and height here, in pixels.

=section #.#.#.#. Sprite Icon Preview

You can optionally choose an image from your assets to use as a sprite "icon".  That is, something to easily identify the sprite in the level editor.  If you omit this, the sprite class name is displayed instead.

=section #.#.#.#. Sprite Persistence

Typically sprites are not "activated" until they are onscreen (see [Aether Sprite System] below).  However, you can designate certain sprite classes as "Always Active", meaning they never deactivate when they leave the screen.

You should be *very* careful when enabling this feature, as too many simultaneous active sprites can slow down your game considerably.  This should be reserved for very special cases.  Note that you can adjust the distance beyond the screen boundaries where sprites are deactivated (see [Aether Distance and Frequency]).

=section #.#.#.#. Sprite Properties

Properties are key/value pairs that you define for your sprite class.  Then you can customize the property values per each sprite instance in the level editor, and all values are made available to your sprite code.  Examples of properties include sprite behavior, energy level, initial direction, starting animation frame, etc.

Each property has an ID, and you can choose the type of visual control, such as a text field, drop-down menu or checkbox.  For example, consider these sprite property definitions:

=image /effect/images/docs/sprites_tiles/sprite_props_define.png
=caption Sprite Property Definitions

Here we have defined three properties for our sprite: "Engine", which is a drop-down menu of engine types, "Fuel", which is a text field for specifying the exact amount of fuel, and "Shields", which is a checkbox indicating if the sprite has shields or not.

Then, in the level editor, when you are placing sprites into a level, you'll see a palette with your defined property controls:

=image /effect/images/docs/sprites_tiles/sprite_props_levedit.png style="border:0"
=caption Sprite Property Palette

The properties are also copied into instances of your sprite class when the level is loaded, using the exact property IDs you specified.  So for the example above, you'd simply have to:

=syntax js
	Ship.add({
		logic: function(clock) {
			switch (this.Engine) {
				case 'standard': /* Standard Engine */ break;
				case 'plasma': /* Plasma Engine */ break;
			};
			
			this.Fuel--;
			if (this.Fuel < 1) {
				// ran out of fuel!
			}
			
			if (this.Shields) {
				// we have shields!
			}
		}
	});

A word of caution: Property values from menus and text fields are always interpreted as strings.  So if you plan to use a property as a number, it is best to call the built-in JavaScript {parseInt()} or {parseFloat()} to convert it.  A good place to do this is in your {setup()} routine.  See [Sprite Setup] below.

=section #.#.#. Sprite Dependencies

Dependencies are other sprite classes that must be loaded when your sprite class loads.  These come into play when you place a sprite into a level which relies on other sprites which |aren't also placed into the level|.  Meaning, sprites that are placed into the level are automatically loaded, but a sprite may need to create a dynamically-generated sprite, such as a projectile, explosion or particle.

=image /effect/images/docs/sprites_tiles/sprite_depends.png style="border:0"
=caption Sprite Dependencies

When defining your sprite class, you can list any number of sprite dependencies, which will be loaded along with your sprite (either at startup, or on demand).

=section #.#.#. Sprite Resources

Sprite Resources are things like images, audio tracks and XML files that your sprite needs.  These can be specified when defining your sprite (just select files from your uploaded game assets), and will automatically be loaded when needed.

=image /effect/images/docs/sprites_tiles/sprite_res.png style="border:0"
=caption Sprite Resources

For example, if your sprite needs to play sound effects, and you don't have the audio tracks set to preload at game startup, you could simply list them as sprite resources here, and they'll be loaded when the sprite loads.

=section #.#.#.#. Image Transforms

If you specify image resources for your sprite (as in the screenshot above), you can optionally select from a number of transformations.  These are applied to the image as it is loaded, adding additional animation frames for special image effects.  These are known as "non-destructive transforms", meaning you can swap out the source image (upload a new version, etc.) and the transform will be re-applied automatically when the image is reloaded for this sprite.

You are of course free to generate your own transformed frames using your favorite image editor.  These built-in transforms are made available for convenience, to get you up and running quickly.  Here are the available transforms:

=section #.#.#.#.#. Scale

Select the "Scale" transform to scale (resize) your image down to zero, over a series of frames.  The actual number of frames varies based on the size of the original image.  Example:

=image /effect/images/docs/sprites_tiles/sprite_scale.png
=caption Image Scaling Transform

Please note that while only 8 frames are shown here, the actual transform adds many more, up to 80 based on the image size.  This is only an example so you can see how the new frames are arranged.  Once your image transform is selected and the image loaded and displayed in the sprite, you can call [api:Sprite.setScale()] to set the size:

=syntax js
	var sprite = Effect.Port.getPlane('sprites').getSprite('mysprite');
	sprite.setScale( 0.5 );

This function simply transforms the scale factor into frames, and then calls [api:Sprite.setFrameX()].

Note that this has no effect on collision detection -- the sprite still technically occupies the same space in the world.  This is purely a visual transform.  However, you are free to manipulate the [api:Sprite.hitRect] to match the scale.

=section #.#.#.#.#. Rotation

Select the "Rotation" transform to rotate your sprite 360 degrees, over a series of frames.  The actual number of frames varies based on the size of the original image.  Example:

=image /effect/images/docs/sprites_tiles/sprite_rotate.png
=caption Image Rotation Transform

Please note that while only 8 frames are shown here, the actual transform adds many more, up to 80 based on the image size, and rotates the image all the way around (360 degrees).  This is only an example so you can see how the new frames are arranged.  Once your image transform is selected and the image loaded and displayed in the sprite, you can call [api:Sprite.setRotation()] to rotate the sprite:

=syntax js
	var sprite = Effect.Port.getPlane('sprites').getSprite('mysprite');
	sprite.setRotation( 180 );

This function simply transforms degrees into frames, and then calls [api:Sprite.setFrameX()].

=section #.#.#.#.#. Rotation + Padding

Select the "Rotation + Padding" transform to rotate your sprite 360 degrees, and automatically add just enough padding so no parts of the image are cropped off due to the rotation.  The actual number of frames varies based on the size of the original image.  Example:

=image /effect/images/docs/sprites_tiles/sprite_rotatepad.png
=caption Image Rotation + Padding Transform

Note that each frame has more padding compared to the standard [Rotation] transform, so that all the pixels are still visible.  Only some images need padding, depending on their shape (circular images typically don't need padding).

Please note that while only 8 frames are shown here, the actual transform adds many more, up to 80 based on the image size, and rotates the image all the way around (360 degrees).  This is only an example so you can see how the new frames are arranged.  Once your image transform is selected and the image loaded and displayed in the sprite, you can call [api:Sprite.setRotation()] to rotate the sprite:

=syntax js
	var sprite = Effect.Port.getPlane('sprites').getSprite('mysprite');
	sprite.setRotation( 180 );

This function simply transforms degrees into frames, and then calls [api:Sprite.setFrameX()].  Also, the sprite width, height and visual offset are adjusted to account for the padding caused by the transform.  When using this transform it is highly recommended to position the sprite based on its center point.

=section #.#.#.#.#. Mirror Horizontal

Select the "Mirror Horiz" transform to generate a "mirror image", so that you'll have a copy of all the frames, but they'll be flipped horizontally.  Example:

=image /effect/images/docs/sprites_tiles/sprite_fliph.png
=caption Horizontal Mirror Transform

Using this transform you can simply call [api:Sprite.setFrameX()] and specify an index beyond the number of normal frames to access the flipped ones.  For example, in this case there are 7 frames in the original image (frame indexes 0 to 6), so you would specify 7 - 13 for the flipped frames.

=section #.#.#.#.#. Mirror Vertical

Select the "Mirror Vert" transform to generate a "mirror image", so that you'll have a copy of all the frames, but they'll be flipped vertically.  Example:

=image /effect/images/docs/sprites_tiles/sprite_flipv.png
=caption Vertical Mirror Transform

Using this transform you can simply call [api:Sprite.setFrameY()] and specify an index of "1" to access the flipped frames (an index of "0" would access the normal, un-flipped frames).

=section #.#.#.#.#. Mirror Both

Select the "Mirror Horiz + Vert" transform to generate a "double mirror image", so you'll have copies of the frames flipped horizontally and vertically.  Example:

=image /effect/images/docs/sprites_tiles/sprite_fliphv.png
=caption Mirror Horiz + Vert Transform

Using this transform you can simply call [api:Sprite.setFrameX()] and specify an index beyond the number of normal frames to access the horiztonally flipped ones, and call [api:Sprite.setFrameY()] with an index of "1" to access the vertically flipped ones (or just call [api:Sprite.setFrame()] to set both the X and Y frame indexes at once).

=section #.#.#.#. Image Filters

In addition to selecting an image transformation (see above), you can also select a filter.  Filters are defined in "Environments" (see the [article:docs/Level Editor Guide]), and are custom sets of filters to adjust the image hue, saturation, brightness, contrast, etc.  Environments are usually applied to an entire level, but you can individually assign them to images here, and the effects are cumulative if the level also has an environment set.

=section #.#. Sprite Planes

A Sprite Plane is a logical layer of sprites in your game world.  You can have multiple Sprite Planes, each with their own settings.  All sprites must belong to a particular plane in order to be active in your game.  You can create sprite planes manually in code, or define them in the Level Editor (in which case they are automatically created when the level loads).

=section #.#.#. Creating Sprite Planes

There are two ways to create sprite planes.  First, you can simply define them in the Level Editor when creating a level, and when the level loads, the sprite planes will automatically be created for you.  Example:

=image /effect/images/docs/sprites_tiles/levedit_layers_sprites.png style="border:0"
=caption Adding Layers (Planes) to a Level

So in this example we have a sprite plane added to the level with an ID of "{sprites}".  When then level is loaded, you can simply request a reference to your plane by calling [api:Effect.Port.getPlane()].  Example:

=syntax js
	var splane = Effect.Port.getPlane('sprites');

The other way to create sprite planes is manually, in your game code.  You can instantiate a [api:SpritePlane] object, pass in your own ID, and then "attach" it to the main display port by calling [api:Effect.Port.attach()].  Example:

=syntax js
	var splane = new SpritePlane( 'sprites' );
	Effect.Port.attach( splane );

At this point the plane is initialized and ready to receive sprites (see [Creating Sprites] below).

=section #.#.#. Sprite Plane Z-Index

Each sprite plane has its own [wikipedia:Z_order, z-index], but this is only a "default" for new sprites within the plane.  Meaning, each sprite may define its own z-index, and this overrides the plane z-index.  In fact, each sprite may be configured to be above, or below, any other plane in the world simply by setting its z-index.

To set the default plane z-index, call [api:Plane.setZIndex()].  Example:

=syntax js
	var splane = Effect.Port.getPlane('sprites');
	splane.setZIndex( 2 );

When sprites are created and added to the plane, and you do not specify an individual z-index, the plane's default z-index is used.  See [Sprite Z-Index] below for details.

Note that changing the [api:Plane.zIndex] does *not* immediately affect all the sprites in the plane, not even those without individual z-index values.  The sprite plane z-index is only a default setting for new sprites.  If you want to immediately set the z-index of all sprites, you can use [api:SpritePlane.findSprites()], then call [api:Sprite.setZIndex()] on the result set.  Example:

=syntax js
	var splane = Effect.Port.getPlane('sprites');
	var list = splane.findSprites(); // find all sprites
	
	// loop through result set, setting z-index of each sprite
	list.each( function(sprite) {
		sprite.setZIndex( 3 );
	});

You can of course chain all these commands together into one, if you like:

=syntax js
	Effect.Port.getPlane('sprites').findSprites().each( function(sprite) {
		sprite.setZIndex( 3 );
	});

=section #.#.#. Sprite Plane Scroll Speed

Each sprite plane may have a custom "scroll speed".  Meaning, when the game world is scrolled via [api:Effect.Port.setScroll()], your sprite plane may scroll at an equal speed, a slower speed, or a faster speed.  This allows you to implement [wikipedia:Parallax scrolling] in your games with ease.

You can set the scroll speed of sprite planes in the Level Editor, or manually if you create the plane by hand.  For the latter, simply call [api:Plane.setScrollSpeed()] and pass in a floating point number:

=syntax js
	var splane = new SpritePlane( 'sprites' );
	splane.setScrollSpeed( 0.5 ); // half speed
	Effect.Port.attach( splane );

Values less than "{1.0}" will scroll slower than normal, values greater than "{1.0}" will scroll faster, and "{0.0}" will not scroll at all (fixed position).  The default value is "{1.0}" (normal speed).

=section #.#.#. Hiding and Showing Sprite Planes

If you want to hide the entire sprite plane, call [api:Plane.hide()].  To show the plane again, call [api:Plane.show()].  Example:

=syntax js
	var splane = Effect.Port.getPlane('sprites');
	splane.hide(); // hides the entire sprite plane
	splane.show(); // shows the entire sprite plane

These methods basically just call [api:Sprite.hide()] or [api:Sprite.show()] on all the sprites in the plane.  This is important to note because, if you individually hid some sprites prior to calling [api:Plane.hide()], their individual visibility states will be "forgotten" when you show the entire plane again.  This functionality may be added in a later engine release.

To determine if an entire plane is currently hidden or visible, check [api:Plane.visible].  Example:

=syntax js
	var splane = Effect.Port.getPlane('sprites');
	if (splane.visible) {
		// plane is visible!
	}

=section #.#.#. Sprite Plane Opacity

To set the global opacity (alpha transparency) of the entire sprite plane, call [api:SpritePlane.setOpacity()], and pass in a floating point number between "{0.0}" (fully transparent) to "{1.0}" (fully opaque).  This will immediately affect all the sprites in the plane.  Example:

=syntax js
	var splane = Effect.Port.getPlane( 'sprites' );
	splane.setOpacity( 0.5 );

Sprite opacity, unlike z-index, is automatically "governed" (multiplied) by the sprite plane opacity in real time.  For example, if you have sprite "A" at 1.0 opacity and sprite "B" at 0.5 opacity, and you set the sprite plane opacity to 0.5, sprite A's effective opacity will become 0.5, and sprite B will be 0.25.

Note that setting the opacity on sprites that have alpha PNG images does not work properly in all browsers (namely IE and Chrome).

=section #.#.#. Removing Sprite Planes

To completely remove a sprite plane from the main display port (and all sprites), call [api:Effect.Port.remove()].  You can either pass in the ID of the sprite plane, or a reference to the object itself.  Example:

=syntax js
	Effect.Port.remove( 'sprites' );

This will not actually destroy any sprite objects, nor will it destroy the plane itself.  This just "removes" it from the main display port (and all graphics), meaning the plane is no longer "attached" and will not receive logic or draw events.  If you save the plane object, you can re-attach it later by calling [api:Effect.Port.attach()].

=section #.#. Sprite Code

This section contains instructions for writing sprite code.  That is, how to setup up your classes, what to do in the logic loop, how to set which image is visible in your sprite, how to control animation, how to move your sprite around, and more.

=section #.#.#. Class Defnition

Your sprites should be subclasses of the built-in [api:Sprite] class.  You can create classes however you like (using a 3rd party class framework, or the old fashioned "prototype" way), but all the examples here use the built-in [article:docs/Object Oriented Framework].

=syntax js
	Sprite.extend( 'MySprite', {
		
		width: 64,
		height: 64,
		url: '/images/sprites/mysprite.png',
		
		logic: function(clock) {
			// your logic routine here
		}
		
	} );

Here we have created a new sprite subclass named "{MySprite}".  This name should exactly match the sprite class name you defined in the web interface.  We've set the size at 64x64 pixels, set the "{url}" property to an image asset path, and declared a "{logic()}" method, which will be called for every iteration through the logic loop.

If your sprite is going to be placed into levels, you don't technically have to define the size in the class, because the engine will set those for you when instances of your sprite are created.  However, it is good practice to always do so.

The "{url}" property becomes the visible image inside the sprite.  Note that the image may be much larger than the sprite size, if it contains multiple frames of animation.  You can later call [api:Sprite.setFrame()], [api:Sprite.setFrameX()] or [api:Sprite.setFrameY()] to control which frame is visible.  You can also call [api:Sprite.setImage()] to swap the image out with another.

The images used by your sprite must be loaded at the time they are used.  Meaning, you should list them as resources in the sprite definition (in the web interface), so they load with the sprite.

There are many more possible properties and methods you can define in your sprite class.  See [api:Sprite Properties] and [api:Sprite Methods] for a complete list.

=section #.#.#. Sprite Setup

If your sprite needs to take action when instances are created in the world (such as, play a sound effect or scan for a target), just define a [api:Sprite.setup()] function in your class:

=syntax js
	MySprite.add({
		setup: function() {
			// sprite is being created, let it be heard!
			Effect.Audio.playSound( 'mysound.mp3' );
		}
	});

So every time an instance of this sprite class is created, either automatically by the engine as it scrolls into view, or manually by calling [api:SpritePlane.createSprite()], the {setup()} method will be called.

In the above example we are simply playing a sound (don't forget to list the sound as a resource, so it is loaded with the sprite), but you can do other things, such as scan the neighborhood for a target sprite, or set the image and/or frame based on property values (see [Sprite Properties]).

=section #.#.#. Sprite Logic

The logic loop is the main heartbeat of your game.  Every iteration through the loop, the {logic()} method is called on all active sprites.  This typically happens many times per second (30, 60, etc.), and is the best place handle your sprite behavior, control animation, move and respond to collisions, etc.  Here is a simple example:

=syntax js
	MySprite.add({
		logic: function(clock) {
			// continually animate based on game clock
			this.setFrameX( clock % 8 );
			
			// move us around
			this.x++;
			this.y++;
		}
	});

The {logic()} method is passed the current logic clock (see [api:Effect.Game.logicClock]).  This integer counter can be used to control animation, as seen by the call to [api:Sprite.setFrameX()].  Assuming our image had 8 frames of animation, this would cycle through them continually, advancing one frame per iteration.  For slower animation, you can divide the clock by a constant before applying the modulus.  For example, this would animate frames at half speed:

=syntax js
	this.setFrameX( Math.floor(clock / 2) % 8 );

Also shown here is how to perform basic movement, by manipulating the [api:Sprite.x] and [api:Sprite.y] properties directly.  In this case simply incrementing each coordinate would move the sprite down and to the right, one pixel per iteration until it left the screen (for what happens after that, see [Offscreen Sprites] below).

=section #.#.#. Moving Around

To move your sprite, you can simply set the [api:Sprite.x] (horizontal) and [api:Sprite.y] (vertical) properties.  These are global world coordinates of the top-left corner of the sprite, with "{0,0}" being the top-left corner of the world.  When these values are changed, the sprite's position on screen will be updated in the next iteration through the draw loop.

=syntax js
	MySprite.add({
		logic: function(clock) {
			// move us around based on keys held down
			if (Effect.Game.isKeyDown('right')) this.x++;
			else if (Effect.Game.isKeyDown('left')) this.x--;
		}
	});

Note that the main display port may be scrolled (see [article:docs/Getting Started Guide|Scrolling]), so your sprite will only be visible if its coordinates are within the scrolled screen bounds.  To tell if a sprite is onscreen, you can call [api:Sprite.isOnScreen()].

To determine if your sprite collided with any other sprites (or tiles), check out the [article:docs/Geometry and Collision Guide].

=section #.#.#. Controlling Animation

Sprite animation is typically achieved by providing an image that contains multiple frames of animation.  The sprite size is only the same as one frame, but you can easily "shift" the image around, exposing any frame in the source image.  For example, consider the following image:

=image /effect/images/docs/sprites_tiles/sprite_frames.png
=caption Sprite image with multiple frames.

This image contains 10 frames, and is 640x64 pixels total, but it can be applied to a sprite that is only 64x64 pixels (the size of one animation frame).  Then, using [api:Sprite.setFrameX()], you can select which frame of the animation is visible in the sprite at any time.  A typical place to do this is in your sprite {logic()} method:

=syntax js
	MySprite.add({
		logic: function(clock) {
			// continually animate based on game clock
			this.setFrameX( clock % 10 );
		}
	});

Here we are using the "%" math operator (remainder of integer division) to set the animation frame between 0 and 9, based on the game logic clock (which is constantly incrementing, once per iteration).  This will cause the frame index to loop indefintely, like this: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, ...

Images can have multiple vertical and/or horizontal frames.  Use [api:Sprite.setFrameY()] to set the vertical frame index, or [api:Sprite.setFrame()] to set both X and Y at once.  Remember these are both zero-based, so "{0,0}" is the top-left frame.

=section #.#.#. Swapping Images

Any any time you can swap out your sprite image with another, as long as the image is loaded (list it as a resource for your sprite).  This is done via the [api:Sprite.setImage()] method.  Pass it an image asset path:

=syntax js
	MySprite.add({
		jump: function() {
			// make character jump
			this.setImage( '/images/sprites/character_jump.png' );
			this.setFrameY( 0, 0 );
			this.yd = -8;
			Effect.Audio.playSound( 'jump.mp3' );
		}
	});

Here we have a typical side-scrolling platformer {jump()} method (assuming this would be called in response to the player hitting a "jump" key control).  First, the sprite image is changed to "{character_jump.png}" which would contain a number of jumping animation frames.  Then we reset the frame index to {0,0} (just in case it was otherwise set before the swap), set our Y delta to a negative number (upwards), and finally, play a jumping sound.

If all your image filenames are unique, you can omit the asset path and just specify the image filename, sans the file extension: "{character_jump}".

It should be noted that swapping the image is a more "expensive" operation compared to setting the frame index.  For performance reasons you should not use this for animation frames, but rather call it less frequently for changing the "state" of a sprite.  For example, you may have separate images for your character standing idle, running, jumping, and ducking, but each image would have multiple frames for each action.

=section #.#.#. Creating Sprites

You can dynamically create new sprites at any time, on any sprite plane.  Just call [api:SpritePlane.createSprite()], pass in a class name, and an optional number of properties for the new sprite (typically "{x}" and "{y}" are set here).  The sprite is immediately placed into the world, and a reference is returned in case you need it.  Example:

=syntax js
	MySprite.add({
		shoot: function() {
			// create a new sprite for our bullet
			this.plane.createSprite( 'Bullet', {
				x: this.x,
				y: this.y - 16,
				xd: 0,
				yd: -8
			});
			Effect.Audio.playSound( 'shoot.mp3' );
		}
	});

This is a typical (albeit simplified) method for shooting a bullet from a player sprite (assuming this would be called in response to the player hitting a "shoot" key control).  In this case we are creating a new "{Bullet}" sprite, setting its position to just above the player sprite (assuming the bullet is 16px high), and setting its delta for movement straight upwards.  Then finally, we play a sound effect for the shot.

Another common use of {createSprite()} is to randomly create enemy sprites or power-up sprites at certain intervals.  These typically aren't created from inside another sprite, but rather in a global event listener for the [api:Effect.Game.onLogic] event.  Example:

=syntax js
	Effect.Game.addEventListener( 'onLogic', function(clock) {
		// randomly create new enemies from time to time
		if (probably( 0.01 )) {
			var plane = Effect.Port.getPlane('sprites');
			plane.createSprite( 'EnemySprite', {
				x: Math.floor( Math.random() * 640 ),
				y: Math.floor( Math.random() * 480 )
			} );
		}
	} );

Here we are spawning enemies at random locations at random times.  We are using the built-in utility function [api:probably()] to calculate a probability of a "1 in 100" chance, and if it returns {true}, we create an enemy sprite.  Since the game logic loop iterates many times per second (typically 30 or 60), this will cause a new enemy to spawn every few seconds or so.

In the above examples we aren't specifying an identifier ("{id}") for the sprites, so one is generated automatically.  However, if you are creating a sprite that you need to be able to fetch by its ID at a later time (via [api:SpritePlane.getSprite()]), you can simply include an "{id}" property, and set it to your own unique string value.  This is good for sprites like your player, of which there is typically only one present in the world, so you can use a known ID value like "{player}".  Example:

=syntax js
	var splane = Effect.Port.getPlane('sprites');
	splane.createSprite( 'MyPlayerSprite', {
		id: 'player',
		x: 0,
		y: 0
	} );
	
	// then later...
	
	var player = splane.getSprite('player');

=section #.#.#. Offscreen Sprites

When your sprites leave the screen, a number of different actions can occur.  You may want some sprites to automatically destroy themselves when they leave the screen (like projectiles, explosions, particle effects, etc.).  You may want others to persist no matter where they are in the world (like your player sprite).  The Effect Engine supports both these options, and has a few more tricks as well.

=section #.#.#.#. Die Offscreen Sprites

If you want sprites to automatically die offscreen, set the [api:Sprite.dieOffscreen] flag to {true} in your sprite class.  Example:

=syntax js
	MySprite.add({
		dieOffscreen: true
	});

The actual distance beyond the edges of the screen before the sprites destroy themselves is configurable per sprite plane.  You can set the distance by calling [api:SpritePlane.setOffscreenDistance()].  The value is the |number of screens| outward in all directions that sprites can live before automatically being destroyed.  For example, "{0.0}" means that sprites are destroyed |immediately| after leaving the screen, while "{1.0}" means that sprites can live exactly one screen, in all directions.  The default value is "{0.5}" (one half screen).  Example:

=syntax js
	var splane = Effect.Port.getPlane('sprites');
	splane.setOffscreenDistance( 0.5 );

It is highly recommended that you use {dieOffscreen} on as many sprite classes as you can, because this reduces the overall number of sprites in the world.  This can greatly help performance.  Sprites like enemies, projectiles, exlposions, power-ups, environmental effects and particles, are all good candidates to die offscreen.

=note Advanced Tip: If you want to be "notified" when your sprites are destroyed, you can override the built-in [api:Sprite.destroy()] method in your class.  However, be sure to explicitly call the base class method so the engine cleans up after your sprite: {this.__parent.destroy.call(this);}

=section #.#.#.#. Screen Loop Sprites

You can configure certain sprites to "loop" around the screen edges, meaning that if they leave the screen, they will instantly move to the reverse screen boundary (sprites that leave the bottom move to the top).  This is similar to the classic "Asteroids" video game.  To use this feature, set the [api:Sprite.screenLoop] flag to {true} on your sprite classes.  Example:

=syntax js
	MySprite.add({
		screenLoop: true
	});

=section #.#.#.#. Persistent Sprites

Persistent sprites remain in the world when they leave the screen.  These sprite classes simply do not have [api:Sprite.dieOffscreen] or [api:Sprite.screenLoop] set on them, and are not [Aether Sprites] (i.e. they were created dynamically using [api:SpritePlane.createSprite()].  You should be careful with these types of sprites, because having too many active sprites in the world can slow down engine performance.

For sprites placed into levels via the Level Editor, these are typically [Aether Sprites], but you can select certain classes to persist by checking the "Always Active" checkbox when editing the sprite class definition.  See the [article:docs/Level Editor Guide] for details.

=section #.#.#.#. Aether Sprites

These sprites are managed by an in-memory database, called the "Aether Database".  Aether sprites that leave the screen are "frozen" in time, removed from the game world, and placed into a database for automatic "defrosting" when they come back onscreen.  The database is indexed in such a way that tens of thousands of sprites can be managed without any performance slowdown, as long as they are suffiently "spread out" over a level.  The idea is, you never want more than 100 - 200 sprites onscreen at any given time, but you may have many more sprites in your level.  The aether database handles defrosting sprites as the screen scrolls near to them, and freezes them again as the screen leaves their area.

Sprites placed into levels via the Level Editor are automatically aether sprites (unless they are flagged as "Always Active") .  But you can also insert your own, dynamically-generated sprites into the aether database, search the database, and remove sprites from it if you like.  For more details, see the [Aether Sprite System] section below.

=section #.#.#. Finding Sprites

There are several ways to locate sprites.  You can search by the sprite's ID, which is extremely fast, or you can search by a [api:Point], [api:Rectangle] or custom search criteira.  The latter three methods are slower because all the active sprites have to be considered.  Here are details for each:

=section #.#.#.#. Finding Sprites By ID

To locate a sprite by its ID, call [api:SpritePlane.getSprite()] and pass in the ID.  This only works for active sprites, not sprites in the aether (see [Aether Sprite System]).  This is an extremely fast call, because all the sprites are indexed by their IDs.  Example:

=syntax js
	var splane = Effect.Port.getPlane('sprites');
	var sprite = splane.getSprite('myid');

You can specify IDs for new sprites when they are first created via [api:SpritePlane.createSprite()], or when sprites are placed via the Level Editor.  You cannot change a sprite's ID once it is active.

=section #.#.#.#. Finding Sprites By Point

To locate sprites by a [api:Point] object (meaning, return any and all sprites that intersect with the point), call [api:SpritePlane.findSpritesByPoint()].  This will return an array containing all the sprites that the point hits.  If any of the sprites have a [api:Sprite.hitRect] defined, that is also taken into account.  Example:

=syntax js
	var splane = Effect.Port.getPlane('sprites');
	var pt = new Point( 50, 50 );
	var list = splane.findSpritesByPoint( pt );

The returned array is augmented with an {each()} method, so you can easily iterate through the results and perform some action on each sprite.  For example, let's say you wanted to delete all the sprites that intersected with a point:

=syntax js
	var splane = Effect.Port.getPlane('sprites');
	var pt = new Point( 50, 50 );
	var list = splane.findSpritesByPoint( pt );
	
	list.each( function(sprite) {
		sprite.destroy();
	});

Another common use of [api:SpritePlane.findSpritesByPoint()] is trying to find out which sprite was clicked on.  However, in that case you probably want to locate a |single| sprite, preferably the one with the highest z-index (the sprite on top).  For that, you can use [api:SpritePlane.lookupSpriteFromGlobal()].  Example:

=syntax js
	Effect.Port.addEventListener( 'onMouseDown', function(pt, buttonIdx) {
		var splane = Effect.Port.getPlane('sprites');
		var sprite = splane.lookupSpriteFromGlobal( pt );
		if (sprite) {
			// sprite was clicked!
		}
	} );

See the [article:docs/Keyboard and Mouse Guide] for details on event handling.

Remember, this is going to be quite a bit slower than locating a sprite by its ID (see above), because |all| the active sprites must be considered.  Try not to call this in every logic loop iteration.

This function only searches active sprites by default.  For searching the aether database, see [Searching The Aether] below.

=section #.#.#.#. Finding Sprites By Rectangle

To locate sprites by a [api:Rect] object (meaning, return any and all sprites that intersect with the rectangle), call [api:SpritePlane.findSpritesByRect()].  This will return an array containing all the sprites that the rect intersects with.  If any of the sprites have a [api:Sprite.hitRect] defined, that is also taken into account.  Example:

=syntax js
	var splane = Effect.Port.getPlane('sprites');
	var rect = new Rect( 0, 0, 50, 50 );
	var list = splane.findSpritesByRect( rect );

The returned array is augmented with an {each()} method, so you can easily iterate through the results and perform some action on each sprite.  For example, let's say you wanted to delete all the sprites that intersected with a rectangle:

=syntax js
	var splane = Effect.Port.getPlane('sprites');
	var rect = new Rect( 0, 0, 50, 50 );
	var list = splane.findSpritesByRect( rect );

	list.each( function(sprite) {
		sprite.destroy();
	});

Remember, this is going to be quite a bit slower than locating a sprite by its ID (see above), because |all| the active sprites must be considered.  Try not to call this in every logic loop iteration.

This function only searches active sprites by default.  For searching the aether database, see [Searching The Aether] below.

=section #.#.#.#. Finding Sprites By Search Criteria

The [api:SpritePlane.findSprites()] method allows you to search a sprite plane for a particular set of criteria, and return all the sprites that match.  For example, you could be looking for a sprite of a particular type (class name), or one with a property set to a particular value.  You can specify one or more criteria, and all must match.  Example:

=syntax js
	var splane = Effect.Port.getPlane('sprites');
	var list = splane.findSprites({
		type: 'Enemy'
	});

You can even specify a callback function for your own custom search routine.  Example:

=syntax js
	var splane = Effect.Port.getPlane('sprites');
	
	var list = splane.findSprites( function(sprite) {
		return( sprite.type == 'Enemy' && sprite.energy < 20 );
	});

The returned array is augmented with an {each()} method, so you can easily iterate through the results and perform some action on each sprite.  For example, let's say you wanted to delete all "Enemy" sprites:

=syntax js
	var splane = Effect.Port.getPlane('sprites');
	var list = splane.findSprites({
		type: 'Enemy'
	});

	list.each( function(sprite) {
		sprite.destroy();
	});

Of course, you could chain all these calls together if you wanted to:

=syntax js
	Effect.Port.getPlane('sprites').findSprites({
		type: 'Enemy'
	}).each( function(sprite) {
		sprite.destroy();
	});

Finally, if you omit the search criteria entirely, *all* active sprites are returned.

Remember, this is going to be quite a bit slower than locating a sprite by its ID (see above), because |all| the active sprites must be considered.  Try not to call this in every logic loop iteration.

This function only searches active sprites by default.  For searching the aether database, see [Searching The Aether] below.

=section #.#.#. Solo Sprite

This feature allows you to designate a single sprite to receive logic events, while all others in the plane will "freeze".  They'll still be drawn onscreen, but their [api:Sprite.logic()] methods will not be called as long as the feature is active.  To do this, call [api:SpritePlane.setSoloSprite()] and pass in the sprite you want to designate.  Example:

=syntax js
	var splane = Effect.Port.getPlane('sprites');
	var player = splane.getSprite('player');
	
	splane.setSoloSprite( player );

For example, you may have a special animation happening on the sprite, and you want everything else to "pause" until the animation completes.  To release the solo sprite and return everything to normal, call [api:SpritePlane.clearSoloSprite()].  Example:

=syntax js
	var splane = Effect.Port.getPlane('sprites');
	splane.clearSoloSprite();

If the solo sprite is destroyed, the feature is automatically disabled, and all sprites resume.

=section #.#.#. Late Logic

For performance reasons, sprites are processed in an undefined order in the logic loop.  Meaning, you can't be sure which sprites will receive {logic()} events before others.  However, there may be cases where you want certain sprites to be processed |at the end|.  To achieve this, simply set the [api:Sprite.lateLogic] flag on your sprite class, and for each iteration through the logic loop, those sprites will be processed |last|.  Example:

=syntax js
	MySprite.add({
		lateLogic: true
	});

One particular use case for this is needing to "synchronize" positions of multiple sprites.  So when the draw loop fires, the "grouped" sprites all appear at the correct positions.  For example, consider a side-scrolling platformer game, and the player is standing on a moving platform.  One way to accomplish this is by having the player "notify" the platform when he is standing on it, in each iteration through the logic loop.  Then, the platform can "adjust" the player's position to match its movement in its logic method, but you want this to happen |after| the player sprite logic.  So in this case, the platform sprite should have [api:Sprite.lateLogic] set, and the player should not.

=section #.#.#. Hiding and Showing Sprites

To hide and show sprites, you can call [api:Sprite.hide()] and [api:Sprite.show()] respectively.  Hidden sprites will still receive logic events, and can respond to collisions, but there will be nothing visible on screen.  Examples:

=syntax js
	var splane = Effect.Port.getPlane( 'sprites' );
	var sprite = splane.getSprite( 'my_sprite_id' );
	
	sprite.hide(); // hide the sprite
	sprite.show(); // show the sprite

You can determine if a sprite is visible or hidden by checking the [api:Sprite.visible] flag.  Example:

=syntax js
	if (sprite.visible) {
		// sprite is visible
	}
	else {
		// sprite is hidden
	}

The [api:Sprite.show()] method can actually hide or show the sprite, if you pass in a boolean argument set to {true} (show) or {false} (hide).  Example:

=syntax js
	sprite.show( false ); // hide the sprite
	sprite.show( true ); // show the sprite

Another example of this is to "toggle" the visibility, by passing in a negated {visible} property.  Example:

=syntax js
	sprite.show( !sprite.visible );

=section #.#.#. Sprite Z-Index

Each sprite has its own [wikipedia:Z_order, z-index] property, which can be set independently of the sprite plane to which they belong.  When sprites are dynamically created with [api:SpritePlane.createSprite()], you have the option of passing in a custom [api:Sprite.zIndex] property.  If this is omitted, the default [api:SpritePlane.zIndex] is copied into the sprite.  Example:

=syntax js
	var splane = Effect.Port.getPlane( 'sprites' );
	
	// create a sprite without a z-index (inherits default from plane)
	splane.createSprite( 'MySprite', {
		x: 50,
		y: 50
	});
	
	// create a sprite and specify a custom z-index
	splane.createSprite( 'MySprite', {
		x: 50,
		y: 50,
		zIndex: 3
	});

You can change the z-index of any sprite at any time, by calling [api:Sprite.setZIndex()].  Example:

=syntax js
	var splane = Effect.Port.getPlane( 'sprites' );
	var sprite = splane.getSprite( 'my_sprite_id' );
	
	sprite.setZIndex( 3 );

=section #.#.#. Sprite Opacity

You can adjust the opacity (alpha transparency) of any sprite by calling [api:Sprite.setOpacity()] and passing in a floating point number between "{0.0}" (fully transparent) to "{1.0}" (fully opaque).  Example:

=syntax js
	var splane = Effect.Port.getPlane( 'sprites' );
	var sprite = splane.getSprite( 'my_sprite_id' );
	
	sprite.setOpacity( 0.5 );

Note that setting the opacity on sprites that have alpha PNG images does not work properly in all browsers (namely IE and Chrome).  Bug reports have been sent to Google and Microsoft about this.

Sprite opacity, unlike z-index, is automatically "governed" (multiplied) by the containing sprite plane opacity in real time.  For example, if you have sprite "A" at 1.0 opacity and sprite "B" at 0.5 opacity, and you set the sprite plane opacity to 0.5, sprite A's effective opacity will be 0.5, and sprite B will be 0.25.  See [Sprite Plane Opacity] for details.

=section #.#.#. Destroying

To manually destroy a sprite, call [api:Sprite.destroy()].  This removes the sprite from the world permanently.  Example:

=syntax js
	var splane = Effect.Port.getPlane('sprites');
	var sprite = splane.getSprite('mysprite');
	sprite.destroy();

Sprites can also destroy themselves, if they want:

=syntax js
	MySprite.add({
		energy: 20,
		logic: function(clock) {
			this.energy--;
			if (!this.energy) this.destroy();
		}
	});

Alternatively, you can destroy sprites by their IDs, by calling [api:SpritePlane.deleteSprites()] and passing a variable argument list.  Example:

=syntax js
	var splane = Effect.Port.getPlane('sprites');
	splane.deleteSprites( 'my_sprite_id1', 'my_sprite_id2' );

=section #.#. Aether Sprite System

The Effect Engine comes with a built-in "database" for managing large amounts of sprites in your levels, called *Aether*.  Since most browsers cannot handle more than 100 to 200 active sprites at once, the Aether system automatically "freezes" and "defrosts" sprites to and from the database, as they scroll on and off the screen.  This allows you to have literally tens of thousands of sprites in your levels, with no performance slowdown.  You can control which sprites are managed by the Aether system, and when they are frozen and defrosted.

Sprites placed into levels via the Level Editor are typically inserted into the Aether database and managed for you, unless you check the "Always Active" checkbox in the sprite class definition.  Sprites created dynamically by your code (via [api:SpritePlane.createSprite()] are *not* automatically managed by the database, because these are usually "temporary" sprites (i.e. projectiles, particle effects, explosions, etc.).  But sprites can be inserted into the database on the fly -- see [Inserting Aether Sprites] below.

In most cases, you don't have to deal with the Aether system directly -- it is designed to run transparently in the background.  Sprites come and go, and you simply write code to handle them |when they are active|.  When sprites leave the screen and are moved into the database, the actual sprite class object is deleted (removed from the world), and only a "stub" remains in the database (the stub contains the class name, position and properties -- nothing else).  When the sprite is retrieved from the database, a new sprite class object is created, and the stub properties are copied back into the sprite object.

You can tell if any given sprite is an Aether sprite, by checking [api:Sprite.isAether()].  The return value will be {true} if the sprite is currently being managed by the Aether system, {false} otherwise.  Example:

=syntax js
	var splane = Effect.Port.getPlane('sprites');
	var sprite = splane.getSprite('mysprite');
	if (sprite.isAether()) {
		// yes, is an aether sprite!
	}

=section #.#.#. Aether Distance and Frequency

By default, aether sprites that leave the screen are |instanty| frozen and moved back to the Aether database.  But if you would prefer, you can adjust the "distance" out in every direction that sprites can continue to remain active before they are frozen.  This also controls the point at which sprites are retrieved from the database and restored into the game world.  To set this distance, call [api:SpritePlane.setAetherDistance()], and pass the |number of screens| in each direction that you would like sprites to live.  For example, "{0.0}" means that sprites are frozen and defrosted |right| at the screen edge (default), while "{1.0}" means that sprites are frozen and defrosted one screen out in every direction.  Example:

=syntax js
	var splane = Effect.Port.getPlane('sprites');
	splane.setAetherDistance( 0.5 ); // one half screen

Please be aware that increasing this distance means more sprites will be active (in the world), and may affect performance.

You can also adjust the frequency at which the aether database is "queried" for pending sprites to be restored into the world.  By default this check is performed every logic frame, but you can slow it down by calling [api:SpritePlane.setAetherCheckFreq()].  The value should be "{1}" for every frame, "{2}" for every other frame, "{3}" for every third frame, and so on.  Example:

=syntax js
	var splane = Effect.Port.getPlane('sprites');
	splane.setAetherCheckFreq( 2 );

Please note that decreasing the check frequency may cause sprites to "pop" into the world when they are already within the screen boundaries.  Use with caution (and preferably in concert with increasing the aether distance), and only if you know exactly what you are doing.

=section #.#.#. Inserting Aether Sprites

By default, sprites created dynamically via [api:SpritePlane.createSprite()] are *not* Aether sprites.  Meaning, when they leave the screen, they will either be destroyed (if [api:Sprite.dieOffscreen] is set), looped around the screen (if [api:Sprite.screenLoop] is set), or will live indefinitely offscreen (if neither property is set).  Sprites placed into levels by the Level Editor are typically Aether sprites.  However, you can "insert" new sprites into the aether database if you desire.

To do this, you need to create a "stub" object.  That is, a generic object with a few key properties, so the Aether database knows how to instantiate the sprite into the world when it scrolls into view.  A stub object should contain the following, at the very least:

=deflist
	{type} | This is the sprite class name, e.g. "{MySprite}".
	{x} | This is the horizontal position of the top-left corner of the sprite in global world coordinates.
	{y} | This is the vertical position of the top-left corner of the sprite in global world coordinates.

You can also include your own custom properties, if you like.  They will be preserved in the database, and copied into a new sprite object when the time comes.  Then, when the sprite leaves the screen and is frozen back into the database, the latest values from all the properties are copied from the sprite object back into the stub.  Note that you *cannot* add a real sprite object to the database -- it must be a generic stub object only.  Example:

=syntax js
	var splane = Effect.Port.getPlane('sprites');
	splane.addToAether({
		type: 'MySprite',
		x: 1000,
		y: 1000,
		myCustomProp: 'foo'
	});

If the specified coordinates are already onscreen, the sprite will immediately be instantiated into the world as a real sprite object.  Otherwise, it will happen later when the sprite scrolls onscreen.  Aether sprites all have a "link" to their athereal counterparts, so the engine knows to freeze and preserve the sprites when they leave the screen later on.

=section #.#.#. Removing Aether Sprites

To remove an active sprite from the Aether system, you can call [api:Sprite.removeFromAether()].  This must be called on a real, active sprite object, not a stub currently frozen and in the database.  The function causes the stub to be removed, so the sprite no longer freezes and transfers to the database when it leaves the screen.  Example:

=syntax js
	var splane = Effect.Port.getPlane('sprites');
	var sprite = splane.getSprite('mysprite');
	sprite.removeFromAether();

From this point on the sprite will behave as a dynamically generated sprite, meaning it will be destroyed when it leaves the screen (if [api:Sprite.dieOffscreen] is set), loop around the screen edges (if [api:Sprite.screenLoop] is set), or live offscreen indefinitely (if neither property is set).

=section #.#.#. Searching The Aether

You can search the aether database just like you search through the active sprites, using [api:SpritePlane.findSpritesByPoint()], [api:SpritePlane.findSpritesByRect()] or [api:SpritePlane.findSprites()].  Simply pass a second argument to each function set to {true}, and the aether database will also be searched, in addition to the active sprites.  Example:

=syntax js
	var splane = Effect.Port.getPlane('sprites');
	var list = splane.findSprites( {type: 'Enemy'}, true );

You can tell if a result is an Aether "stub" object, or a real sprite, by checking to see if the object has a standard [api:Sprite] method, such as [api:Sprite.logic].  If so, then the object came from the active sprite list, not the Aether database (Aether stubs are generic objects, not real sprites).

Remember that searching the entire Aether database is going to be slow (depending on the total number of sprites in the level), so only call this at strategic moments (preferably not in your sprite {logic()} method).

=section #. Tiles

Tiles are square or rectangular graphics that are rendered in a two-dimensional "grid".  This is a classic way to create level graphics, used heavily back in the 8-bit game era.  Tiles are simply images (JPEGs, GIFs or PNGs) that you must upload and assign to a "Tileset".  Tiles can by any size, and do not need to be square (however, all the tiles in a Tileset must be the same size).  Here is an example of some 64x64 pixel tiles:

<center><table cellspacing="5" cellpadding="0"><tr><td class="checkers"><img src="/effect/images/docs/sprites_tiles/hedge_C.png" width="64" height="64" style="border:1px solid #ccc;"/></td><td class="checkers"><img src="/effect/images/docs/sprites_tiles/hedge_L.png" width="64" height="64" style="border:1px solid #ccc;"/></td><td class="checkers"><img src="/effect/images/docs/sprites_tiles/hedge_R.png" width="64" height="64" style="border:1px solid #ccc;"/></td><td class="checkers"><img src="/effect/images/docs/sprites_tiles/hedge_T.png" width="64" height="64" style="border:1px solid #ccc;"/></td><td class="checkers"><img src="/effect/images/docs/sprites_tiles/hedge_B.png" width="64" height="64" style="border:1px solid #ccc;"/></td><td class="checkers"><img src="/effect/images/docs/sprites_tiles/hedge_DTL.png" width="64" height="64" style="border:1px solid #ccc;"/></td><td class="checkers"><img src="/effect/images/docs/sprites_tiles/hedge_DTR.png" width="64" height="64" style="border:1px solid #ccc;"/></td><td class="checkers"><img src="/effect/images/docs/sprites_tiles/hedge_DBL.png" width="64" height="64" style="border:1px solid #ccc;"/></td><td class="checkers"><img src="/effect/images/docs/sprites_tiles/hedge_DBR.png" width="64" height="64" style="border:1px solid #ccc;"/></td></tr></table></center>

For example, the above tiles could be placed into the following configuration, creating a piece of a game level:

=image /effect/images/docs/sprites_tiles/hedge_level.png
=caption Example tile arrangement in level.

Tiles may used for foreground and/or background graphics.  By having several layers of tile graphics scrolling at different speeds (see [Tile Plane Scroll Speed] below), you can achieve [wikipedia:Parallax scrolling].

For foreground tiles, you can include an invisible "data" layer that contains information for your game code.  For example, using the Level Editor you can assign classes to tiles, such as ground, walls, special items, etc.  You can then detect which tiles have classes by using collision detection.

=section #.#. Tilesets

A Tileset is basically a directory of tile image assets, which can then be "assigned" to a particilar tile plane, and used in a level.  To create a tileset, first upload and organize your tile images into folders using the "Assets" tab (see the [article:docs/Asset Manager Guide]).  All the images that should belong to a particular Tileset should be in their own folder.  Then, proceed to the "Objects" tab and click the "Add Tileset" link:

=image /effect/images/docs/sprites_tiles/tilesets.png
=caption List of Tilesets.

This page also shows your current Tilesets, and allows you to edit them.  Clicking the "Edit" link or the "Add Tileset" link brings you to the [Tileset Editor].

=section #.#.#. Tileset Editor

The Tileset Editor is where you can create or edit Tileets.  This involves assigning the Tileset an ID, which can contain alphanumeric characters, dashes, underscores and periods.  Then simply choosing an asset folder where your tile images live.

=image /effect/images/docs/sprites_tiles/tileset_edit.png
=caption Creating a new Tileset.

Once you choose an asset folder, a preview will be displayed.  When you are satisfied, click the "Create Tileset" or "Save Changes" button.

=section #.#. Tile Planes

A Tile Plane is a single layer of tile graphics in your game world.  You may have multiple Tile Planes, each with a different Tileset, different [wikipedia:Z_order, z-index], and even a different scroll speed, if you want.  You can create tile planes manually in code, or define them in the Level Editor (in which case they are automatically created when the level loads).

=section #.#.#. Creating Tile Planes

There are two ways to create tile planes. First, you can simply define them in the Level Editor when creating a level, and when the level loads, the tiles planes will automatically be created for you. Example:

=image /effect/images/docs/sprites_tiles/levedit_layers_tiles.png style="border:0"
=caption Adding Layers (Planes) to a Level

So in this example we have a tile plane added to the level with an ID of "{tiles}".  When then level is loaded, you can simply request a reference to your plane by calling [api:Effect.Port.getPlane()].  Example:

=syntax js
	var tplane = Effect.Port.getPlane('tiles');

The other way to create tile planes is manually, in your game code.  You can instantiate a [api:TilePlane] object, pass in your own ID, assign it a Tileset, and then "attach" it to the main display port by calling [api:Effect.Port.attach()].  Example:

=syntax js
	var tplane = new TilePlane( 'tiles' );
	tplane.setTileset( 'MyTilesetID' );
	Effect.Port.attach( tplane );

At this point the plane is initialized and ready.  An important distinction here is that using the Level Editor not only auto-creates your tile planes for you, but it also populates them with content.  If you create your tile plane manually, you also have to draw all the individual tiles into the plane.  See [Setting Tiles] below for details. 

=section #.#.#. Tile Plane Z-Index

Each tile plane has its own [wikipedia:Z_order, z-index], which controls the draw order (which planes are in front of others).  Higher values are on top, lower values are on the bottom.  Every tile in the plane shares the same z-index as the plane itself.  To set the z-index, call [api:Plane.setZIndex()]:

=syntax js
	var tplane = Effect.Port.getPlane('tiles');
	tplane.setZIndex( 3 );

You can change the z-index of a tile plane at any time, even during game play.

=section #.#.#. Tile Plane Scroll Speed

Each tile plane may have a custom "scroll speed".  Meaning, when the game world is scrolled via [api:Effect.Port.setScroll()], your tile plane may scroll at an equal speed, a slower speed, or a faster speed.  This allows you to implement [wikipedia:Parallax scrolling] in your games with ease.

You can set the scroll speed of tile planes in the Level Editor, or manually if you create the plane by hand.  For the latter, simply call [api:Plane.setScrollSpeed()] and pass in a floating point number:

=syntax js
	var tplane = new TilePlane( 'tiles' );
	tplane.setScrollSpeed( 0.5 ); // half speed
	tplane.setTileset( 'MyTilesetID' );
	Effect.Port.attach( tplane );

Values less than "{1.0}" will scroll slower than normal, values greater than "{1.0}" will scroll faster, and "{0.0}" will not scroll at all (fixed position).  The default value is "{1.0}" (normal speed).

=section #.#.#. Hiding and Showing Tile Planes

If you want to hide the entire tile plane, call [api:Plane.hide()].  To show the plane again, call [api:Plane.show()].  Example:

=syntax js
	var tplane = Effect.Port.getPlane('tiles');
	tplane.hide(); // hides the entire tile plane
	tplane.show(); // shows the entire tile plane

To determine if an entire plane is currently hidden or visible, check [api:Plane.visible].  Example:

=syntax js
	var tplane = Effect.Port.getPlane('tiles');
	if (tplane.visible) {
		// plane is visible!
	}

=section #.#.#. Tile Plane Opacity

To set the global opacity (alpha transparency) of the entire tile plane, call [api:TilePlane.setOpacity()], and pass in a floating point number between "{0.0}" (fully transparent) to "{1.0}" (fully opaque).  This will immediately affect all the tiles in the plane.  Example:

=syntax js
	var tplane = Effect.Port.getPlane( 'tiles' );
	tplane.setOpacity( 0.5 );

Note that setting the opacity on planes that have alpha PNG images does not work properly in all browsers (namely IE and Chrome).

=section #.#.#. Removing Tile Planes

To completely remove a tile plane from the main display port (and all tiles), call [api:Effect.Port.remove()].  You can either pass in the ID of the tile plane, or a reference to the object itself.  Example:

=syntax js
	Effect.Port.remove( 'tiles' );

This will not actually destroy any tile objects, nor will it destroy the plane itself.  This just "removes" it from the main display port (and all graphics), meaning the plane is no longer "attached" and will not receive logic or draw events.  If you save the plane object, you can re-attach it later by calling [api:Effect.Port.attach()].

=section #.#. Tile Classes

Tile Classes allow you to assign "behaviors" to tiles, so they can execute code as they come onscreen, or respond to collisions with sprites.  These objects can be created in the Level Editor or by hand, and assigned to the "data layer" of a tile plane.

Each tile plane may or may not have a data layer.  You can create one in the Level Editor, or manually create some tile objects and set them in the plane (which also creates a data layer).  See [Setting Tiles] below for details.

=section #.#.#. Tile Class Definition

There are two parts to a tile class definition.  First, you must define class in the web interface.  This allows you to place tile objects in the Level Editor, and define custom properties.  This is done from the "Objects" tab, by clicking the "Add Tile Class" link:

=image /effect/images/docs/sprites_tiles/objects_tiles.png
=caption List of tile classes.

This also lists all your current tile classes, with links to edit or delete them.  Clicking either "Edit" on an existing tile class, or the "Add Tile Class" link, brings you to the Tile Class Editor.  It collects the following information for the class:

=section #.#.#.#. Tile Class Name

This is the class name for the file, which match the name of the class when you define it in your game code.  Alphanumerics and periods only.  If your class is nested inside one or more namespaces, please include them here, periods and all.

=section #.#.#.#. Tile Icon Preview

You can optionally choose an image from your assets to use as a tile "icon". That is, something to easily identify the tile in the level editor. If you omit this, the tile class name is displayed instead.

=section #.#.#.#. Tile Properties

Tile Properties work in the same way as [Sprite Properties].  You can define any number of key/value pairs, which you can then populate with data in the Level Editor.  Then, when your level is loaded, your tile objects will contain all the properties you defined, and their respective values for each tile instance.

For an example of how to use tile properties, imagine a tile that you can hit and have it emit a power-up item.  You could define a property that describes the type of power-up to emit.  Here is how the property editor would look:

=image /effect/images/docs/sprites_tiles/tile_props.png style="border:0"

Then, when you define your tile class in your game code, including a function for emitting the power-up sprite:

=syntax js
	Tile.extend( 'MyPowerUpTile', {
		emit: function() {
			// emit a power-up
			// this will be called on a collision
			Effect.Port.getPlane('sprites').createSprite( this.PowerUp, {
				x: this.tx * this.plane.tileSizeX,
				y: this.ty * this.plane.tileSizeY
			} );
			Effect.Audio.playSound( 'powerup.mp3' );
		}
	} );

So the first thing to note here, is "{this.powerUp}", which will be automatically populaed with the property value of the same name when the tile object is instantiated in the level.  So depending on the value selected from the drop-down menu (Shields, Phasers, etc.), this is the name of the sprite class we are creating.

Secondly, notice how we are setting the new sprite position.  We use [api:Tile.tx] and [api:Tile.ty] which is the tile index location of the current tile, multiplied by the [api:TilePlane.tileSizeX] and [api:TilePlane.tileSizeY] respectively, to get the actual pixel coordinates for a new sprite positioned right on top of the tile (assuming the sprite is the same size as the tile).

Finally, to tie this all together, we have to somehow call the {emit()} function.  Imagine a collision detection routine, such as the movement of a projectile weapon, fired by the player.  If the projectile hits the power-up tile, we want to emit the power-up.  Simple example:

=syntax js
	Sprite.extend( 'MyProjectile', {
		logic: funciton(clock) {
			// move projectile and check for collisions
			var hit = this.move();
			if (hit) {
			 	// we hit something!
				if (hit.target.type == 'MyPowerUpTile') {
					// we hit a power-up tile!
					hit.target.emit();
				}
				// destroy projectile
				this.destroy();
			}
		}
	} );

For more details on collision detection, see the [article:docs/Geometry and Collision Guide].

=section #.#.#.#. Tile Dependencies

Dependencies are other sprite classes that must be loaded when your tile class loads. These come into play when you place a tile into a level which relies on other sprites which aren't also placed into the level.  Meaning, sprites that are explicitly placed into the level are automatically loaded, but a tile may need to create a dynamically-generated sprite, such a power-up, as in the above example.  In that case, you should list all the sprites that the tile may create as dependencies.

=image /effect/images/docs/sprites_tiles/sprite_depends.png style="border:0"

=section #.#.#.#. Tile Resources

Tile Resources are things like images, audio tracks and XML files that your tile class needs. These can be specified when defining your tile class (just select files from your uploaded game assets), and will automatically be loaded when needed.

=image /effect/images/docs/sprites_tiles/tile_res.png style="border:0"

=section #.#.#.#. Tile Code

After you successfully register the tile class with the web interface, you need to create a matching class in your game code.  This allows you to set collision properties such as marking the tile as "solid", among other things.  Your tile classes should inherit from the built-in base [api:Tile] class.  Example tile class definition:

=syntax js
	Tile.extend( 'Ground', {
		collisions: true,
		solid: true
	} );

This creates a new tile class called "{Ground}", which has its [api:Tile.collisions] and [api:Tile.solid] properties set to {true}.  That means collisions with the tile will be calculated with moving sprites, and automatically be corrected (see the [article:docs/Geometry and Collision Guide] for details on this).

Instances of your class will be created for every data tile with the same class name.  You can gain access to these objects using the methods described below.

=section #.#.#. Finding Tiles

To locate tiles in a plane, you can use the [api:TilePlane.lookupTile()] method.  Given horizontol and vertial tile indexes, this can lookup tile class objects (from the data layer) or visual tile image filenames.  Examples:

=syntax js
	var tplane = Effect.Port.getPlane('tiles');
	
	// lookup tile class object at position 5x5
	var obj = tplane.lookupTile( 5, 5, true );
	assert( obj.type == 'MyPowerUpTile' );
	
	// lookup visual tile image at position 5x5
	var filename = tplane.lookupTile( 5, 5, false );
	assert( filename == 'tile01.gif' );

The last argument to the function controls whether to query the data layer ({true}), or the visual layer ({false}).  For data queries, if a tile object occupies the location, a reference to the object is returned, or {0} if no object was found.  For the visual layer, the tile filename will be returned, or {0} if no tile occupies the location.

The horizontal and vertical values passed to the function are positional indexes in the tile "array".  The values start at 0, and "{0, 0}" represents the upper-left tile in the level.  If you prefer to lookup tiles by global coordinates instead, take a look at [api:TilePlane.lookupTileFromGlobal()].

=section #.#.#. Setting Tiles

You can also set tiles in your tile planes.  That is, change the visual and/or data tiles to any values you like.  You can also use this to populate levels with your own custom content (i.e. not created in the level editor).  To do this, use the [api:TilePlane.setTile()] method.  Examples:

=syntax js
	var tplane = Effect.Port.getPlane('tiles');
	
	// change position 5x5 data to be 'Ground' tile
	var tile = new Ground();
	tplane.setTile( 5, 5, tile, true );
	
	// change position 5x5 visual to be 'tile01.gif' image
	tplane.setTile( 5, 5, "tile01.gif", false );

As with [api:TilePlane.lookupTile()], the last argument to the function controls whether to set the data layer ({true}), or the visual layer ({false}).

You can also set tiles by specifying global coordinates instead of tile indexes.  For this, use [api:TilePlane.setTileFromGlobal()].

=section #.#.#. onScreen Event

Your tile objects will receive an "{onScreen}" event as they scroll into view.  To "listen" for this event, simply include an {onScreen()} function in your tile class.  For example, here is a class that emits an enemy sprite whenever it appears onscreen:

=syntax js
	Tile.extend( 'MyEmitter', {
		onScreen: function() {
			// we appeared onscreen!  emit a sprite!
			Effect.Port.getPlane('sprites').createSprite( 'Enemy', {
				x: this.tx * this.plane.tileSizeX,
				y: this.ty * this.plane.tileSizeY
			} );
			Effect.Audio.playSound( 'emit.mp3' );
		}
	} );

Note that this event is not called on all the inital onscreen tiles when a level is loaded.  To "force" this to happen, simply call [api:TilePlane.activateScreenObjects()] after loading a level.

=section #. Examples

=list
	[/effect/example.psp.html?rev=sprites_tiles1 Basic Sprite and Tile Demo]
